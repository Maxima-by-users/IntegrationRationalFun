/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: comment start ]
Reescreve, se possível, a expressão 𝐴 de modo que se torne um polinômio na variável 𝑥, onde cada potência de 𝑥 ocorre apenas uma vez. Além disso, simplifica os coeficientes de cada termo em 𝑥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Group(A,x):=
block([a,l,simp,Ans],
    algebraic:true,
    simp:0,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:expandwrt(fullratsimp(A,x),x),
    l:hipow(a,x),
    for i:0 thru l do (
        simp:simp+fullratsimp(coeff(a,x,i))*x^i
    ),
    Ans:simp,
    algebraic:false,
    return(ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O coeficiente líder do polinômio 𝐴 na variável 𝑥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LC(A,x):=
block([a,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:Group(A,x),
    a:coeff(a,x,hipow(a,x)),
    Ans:a,
    algebraic:false,return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O polinômio mônico de 𝐴 na varável 𝑥. Obtido pela divisão de 𝐴 por seu termo líder em 𝑥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Mon(A,x):=
block([a,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:Group(A/LC(A,x),x),
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna polinômios 𝐴 e 𝐵 tais que 𝑃(𝑢 + 𝐼𝑣) = 𝐴(𝑢,𝑣) + 𝐼𝐵(𝑢,𝑣), com os coeficientes de 𝐴 e 𝐵 pertencentes ao mesmo domínio dos coeficientes de 𝑃.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Parts(P,z):=
block([u,v,p,Ans],
    algebraic:true,
    p:subst(u+%i*v,z,P),
    Ans:[realpart(p),imagpart(p)],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Gera polinômios inteiros aleatórios. 𝑑𝑒𝑔 é o grau desejado, 𝑙𝑖𝑚 é o limitante para o valor absoluto dos coeficientes e 𝑑𝑜𝑚 é o domínio: naturais ou inteiros.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RPoly(x,deg,lim,dom):=
block([j,s,Poly,Ans],
    algebraic:true,
    Poly:0,
    for j:0 thru deg do (
        s:1,
        if random(2)=0 and dom="integers" then s:-1,
        Poly:Poly+s*random(lim+1)*x^j
    ),
    if hipow(Poly,x)<deg then Poly:Poly+x^deg,
    if Poly=0 then (
        Ans:1,
        algebraic:false,return(Ans)
    ),
    Ans:Poly,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna o quociente e o resto da divisão de 𝐴 por 𝐵 visto como polinômios em 𝑥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função PolyDivide(𝐴,𝐵)
2: descrição: Dado um corpo K e 𝐴,𝐵 ∈ K[𝑥] com 𝐵 ̸= 0, retorna 𝑄,𝑅 ∈ K[𝑥] tais que 𝐴 = 𝐵𝑄 + 𝑅, com 𝑅 = 0 ou grau(𝑅) < grau(𝐵).
3: 𝑄 ← 0
4: 𝑅 ← 𝐴
5: enquanto 𝑅 ̸= 0 e 𝛿 ← grau(𝑅) − grau(𝐵) ≥ 0 faça
6: 𝑇 ← cl(𝑅) cl(𝐵) 𝑥 𝛿
7: 𝑄 ← 𝑄 + 𝑇
8: 𝑅 ← 𝑅 − 𝐵𝑇
9: fim enquanto
10: devolve (𝑄,𝑅)
11: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PDiv(A,B,x):=
block([b,q,r,t,delta,lcB,degB,Ans],
    algebraic:true,
    q:0,
    r:Group(A,x),
    b:Group(B,x),
    degB:hipow(b,x),
    delta:hipow(r,x)-degB,
    lcB:LC(b,x),
    while r#0 and delta>=0 do (
        t:fullratsimp(LC(r,x)/lcB)*x^delta,
        q:q+t,
        r:r-b*t,
        q:Group(q,x),
        r:Group(r,x),
        delta:hipow(r,x)-degB
    ),
    Ans:[q,r],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna o pseudoquociente e o pseudoresto da divisão de 𝐴 por 𝐵 visto como polinômios em 𝑥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função PolyPseudoDivide(𝐴,𝐵)
2: descrição: Dado um domínio de integridade 𝐷 e 𝐴,𝐵 ∈ 𝐷[𝑥] com 𝐵 ̸= 0, retorna pquo(𝐴,𝐵) e prem(𝐴,𝐵).
3: 𝑏 ← cl(𝐵)
4: 𝑁 ← grau(𝑅) − grau(𝐵) + 1
5: 𝑄 ← 0
6: 𝑅 ← 𝐴
7: enquanto 𝑅 ̸= 0 e 𝛿 ← grau(𝑅) − grau(𝐵) ≥ 0 faça
8: 𝑇 ← cl(𝑅)𝑥 𝛿
9: 𝑁 ← 𝑁 − 1
10: 𝑄 ← 𝑏𝑄 + 𝑇
11: 𝑅 ← 𝑏𝑅 − 𝐵𝑇
12: fim enquanto
13: devolve (𝑏 𝑁 𝑄,𝑏𝑁 𝑅)
14: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PPsDiv(A,B,x):=
block([b,q,r,t,delta,lcB,degB,N],
    algebraic:true,
    q:0,
    r:Group(A,x),
    b:Group(B,x),
    degB:hipow(b,x),
    delta:max(hipow(r,x)-degB,-1),
    lcB:LC(b,x),
    N:delta+1,
    while r#0 and delta>=0 do (
        t:LC(r,x)*x^delta,
        N:N-1,
        q:lcB*q+t,
        r:lcB*r-b*t,
        q:Group(q,x),
        r:Group(r,x),
        delta:hipow(r,x)-degB
    ),
    q:Group(lcB^N*q,x),
    r:Group(lcB^N*r,x),
    Ans:[q,r],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Cálculo de mdc de polinômios utilizando a SRP primitiva. Há a possibilidade de se realizar os cálculos módulo 𝑃(𝑧). Isto se mostrará útil especialmente no algoritmo de Rothstein-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função Euclidean(𝑎,𝑏)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏 ∈ 𝐷, retorna mdc(𝑎,𝑏).
3: enquanto 𝑏 ̸= 0 faça
4: (𝑞,𝑟) ← EuclideanDivision(𝑎,𝑏) ◁ 𝑎 = 𝑏𝑞 + 𝑟
5: 𝑎 ← 𝑏
6: 𝑏 ← 𝑟
7: fim enquanto
8: devolve 𝑎
9: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
GCD(A,B,x,P,z):=
block([a,b,q,r,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    if P#0 then (
        a:PPsDiv(a,P,z)[2],
        b:PPsDiv(b,P,z)[2]
    ),
    while b#0 do (
        [q,r]:PPsDiv(a,b,x),
        if P#0 then (
            r:PPsDiv(num(r),P,z)[2],
            if r#0 then r:content(Group(r,x),x)[2]
        ),
        a:b,
        b:content(r,x)[2],
        if r=0 then b:0
    ),
    a:content(a,x)[2],
    if LC(a,x)<0 then (
        a:Group((-a),x)
    ),
    Ans:a,
    algebraic:false,return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides estendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função ExtendedEuclidean(𝑎,𝑏)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏 ∈ 𝐷, retorna 𝑠,𝑡,𝑑 ∈ 𝐷 tais que 𝑑 = mdc(𝑎,𝑏) e 𝑠𝑎 + 𝑡𝑏 = 𝑑.
3: 𝑎1 ← 1
4: 𝑎2 ← 0
5: 𝑏1 ← 0
6: 𝑏2 ← 1
7: enquanto 𝑏 ̸= 0 faça
8: (𝑞,𝑟) ← EuclideanDivision(𝑎,𝑏) ◁ 𝑎 = 𝑏𝑞 + 𝑟
9: 𝑎 ← 𝑏
10: 𝑏 ← 𝑟
11: 𝑟1 ← 𝑎1 − 𝑞𝑏1
12: 𝑟2 ← 𝑎2 − 𝑞𝑏2
13: 𝑎1 ← 𝑏1
14: 𝑎2 ← 𝑏2
15: 𝑏1 ← 𝑟1
16: 𝑏2 ← 𝑟2
17: fim enquanto
18: devolve (𝑎1,𝑎2,𝑎)
19: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ExGCD(A,B,x):=
block([a,b,q,r,a1,a2,b1,b2,r1,r2,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    a1:1,
    a2:0,
    b1:0,
    b2:1,
    while b#0 do (
        [q,r]:PDiv(a,b,x),
        a:b,
        b:r,
        r1:a1-q*b1,
        r2:a2-q*b2,
        a1:b1,
        a2:b2,
        b1:r1,
        b2:r2
    ),
    Ans:expand([a1,a2,a]),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides semiestendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HalfExtendedEuclidean(𝑎,𝑏)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏 ∈ 𝐷, retorna 𝑠,𝑑 ∈ 𝐷 tais que 𝑑 = mdc(𝑎,𝑏) e 𝑠𝑎 + 𝑡𝑏 = 𝑑 para algum 𝑡 ∈ 𝐷.
3: 𝑎1 ← 1
4: 𝑏1 ← 0
5: enquanto 𝑏 ̸= 0 faça
6: (𝑞,𝑟) ← EuclideanDivision(𝑎,𝑏) ◁ 𝑎 = 𝑏𝑞 + 𝑟
7: 𝑎 ← 𝑏
8: 𝑏 ← 𝑟
9: 𝑟1 ← 𝑎1 − 𝑞𝑏1
10: 𝑎1 ← 𝑏1
11: 𝑏1 ← 𝑟1
12: fim enquanto
13: devolve (𝑎1,𝑎)
14: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HExGCD(A,B,x):=
block([a,b,q,r,a1,b1,r1,Ans],
    algebraic:true,
    a:A,
    b:B,
    a1:1,
    b1:0,
    while b#0 do (
        [q,r]:PDiv(a,b,x),
        a:b,
        b:r,
        r1:a1-q*b1,
        a1:b1,
        b1:r1
    ),
    Ans:[a1,a],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides estendido calculado a partir do semiestendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função ExtendedEuclidean(𝑎,𝑏)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏 ∈ 𝐷, retorna 𝑠,𝑡,𝑑 ∈ 𝐷 tais que 𝑑 = mdc(𝑎,𝑏) e 𝑠𝑎 + 𝑡𝑏 = 𝑑.
3: (𝑠,𝑑) ← HalfExtendedEuclidean(𝑎,𝑏) ◁ 𝑠𝑎 + 𝑡𝑏 = 𝑑 para algum 𝑡
4: (𝑡,𝑟) ← EuclideanDivision(𝑑 − 𝑠𝑎,𝑏) ◁ 𝑟 deve ser 0
5: devolve (𝑠,𝑡,𝑑)
6: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HFExGCD(A,B,x):=
block([a,b,s,r,g,t,Ans],
    algebraic:true,
    a:A,
    b:B,
    [s,g]:HExGCD(a,b,x),
    [t,r]:PDiv(g-s*A,B,x),
    Ans:[s,t,g],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão diofantina do algoritmo de Euclides estendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função ExtendedEuclidean(𝑎,𝑏,𝑐)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏,𝑐 ∈ 𝐷 e 𝑐 múltiplo de mdc(𝑎,𝑏), retorna 𝑠,𝑡 ∈ 𝐷 tais que 𝑠𝑎 + 𝑡𝑏 = 𝑐, com 𝑠 = 0 ou 𝜈(𝑠) < 𝜈(𝑏).
3: (𝑠,𝑡,𝑑) ← ExtendedEuclidean(𝑎,𝑏) ◁ 𝑑 = 𝑠𝑎 + 𝑡𝑏
4: (𝑞,𝑟) ← EuclideanDivision(𝑐,𝑑) ◁ 𝑐 = 𝑑𝑞 + 𝑟
5: se 𝑟 ̸= 0 então
6: erro: “𝑐 não é múltiplo de mdc(𝑎,𝑏)”
7: fim se
8: 𝑠 ← 𝑞𝑠
9: 𝑡 ← 𝑞𝑡
10: se 𝑠 ̸= 0 e 𝜈(𝑠) ≥ 𝜈(𝑏) então
11: (𝑞,𝑟) ← EuclideanDivision(𝑠,𝑏) ◁ 𝑠 = 𝑏𝑞 + 𝑟
12: fim se
13: 𝑠 ← 𝑟
14: 𝑡 ← 𝑡 + 𝑞𝑎
15: devolve 𝑠,𝑡
16: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioExGCD(A,B,C,x):=
block([s,t,g,q,r,Ans],
    algebraic:true,
    [s,t,g]:HFExGCD(A,B,x),
    [s,t,g]:expand([s,t,g]),
    [q,r]:PDiv(C,g,x),
    if r#0 then (
        algebraic:false,
        error("c is not in the ideal generated by a and b")
    ),
    s:q*s,
    t:q*t,
    [s,t]:expand([s,t]),
    if s#0 and hipow(s,x)>=hipow(B,x) then (
        [q,r]:PDiv(s,B,x),
        s:r,
        t:t+q*A
    ),
    Ans:[s,t],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão diofantina do algoritmo de Euclides semiestendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HalfExtendedEuclidean(𝑎,𝑏,𝑐)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏,𝑐 ∈ 𝐷 e 𝑐 múltiplo de mdc(𝑎,𝑏), retorna 𝑠 ∈ 𝐷 tal que 𝑠𝑎 + 𝑡𝑏 = 𝑐 para algum 𝑡 ∈ 𝐷, com 𝑠 = 0 ou 𝜈(𝑠) < 𝜈(𝑏).
3: (𝑠,𝑑) ← HalfExtendedEuclidean(𝑎,𝑏) ◁ 𝑠𝑎 + 𝑡𝑏 = 𝑑 para algum 𝑡 ∈ 𝐷
4: (𝑞,𝑟) ← EuclideanDivision(𝑐,𝑑) ◁ 𝑐 = 𝑑𝑞 + 𝑟
5: se 𝑟 ̸= 0 então
6: erro: 𝑐 não é múltiplo de mdc(𝑎,𝑏)
7: fim se
8: 𝑠 ← 𝑞𝑠
9: se 𝑠 ̸= 0 e 𝜈(𝑠) ≥ 𝜈(𝑏) então
10: (𝑞,𝑟) ← EuclideanDivision(𝑠,𝑏) ◁ 𝑠 = 𝑏𝑞 + 𝑟
11: fim se
12: 𝑠 ← 𝑟
13: devolve 𝑠
14: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioHExGCD(A,B,C,x):=
block([s,g,q,r,Ans],
    algebraic:true,
    [s,g]:HExGCD(A,B,x),
    [s,g]:expand([s,g]),
    [q,r]:PDiv(C,g,x),
    if r#0 then (
        algebraic:false,
        error("c is not in the ideal generated by a and b")
    ),
    s:q*s,
    s:expand(s),
    if s#0 and hipow(s,x)>=hipow(B,x) then (
        [q,r]:PDiv(s,B,x),
        s:r
    ),
    Ans:s,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão diofantina do algoritmo de Euclides calculado a partir do semiestendido. Aplicável a domínios euclidianos de polinômios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função ExtendedEuclidean(𝑎,𝑏)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑏,𝑐 ∈ 𝐷, com 𝑐 múltiplo de mdc(𝑎,𝑏) retorna 𝑠,𝑡 ∈ 𝐷 tais que 𝑠𝑎 + 𝑡𝑏 = 𝑐, com 𝑠 = 0 ou 𝜈(𝑠) < 𝜈(𝑏).
3: 𝑠 ← HalfExtendedEuclidean(𝑎,𝑏,𝑐) ◁ 𝑠𝑎 + 𝑡𝑏 = 𝑐 para algum 𝑡
4: (𝑡,𝑟) ← EuclideanDivision(𝑐 − 𝑠𝑎,𝑏) ◁ 𝑟 deve ser 0
5: devolve (𝑠,𝑡)
6: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioHFExGCD(A,B,C,x):=
block([s,r,t,Ans],
    algebraic:true,
    s:DioHExGCD(A,B,C,x),
    [t,r]:PDiv(C-s*A,B,x),
    Ans:[s,t],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo das subresultantes.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função SubResultant(𝐴,𝐵)
2: descrição: Dado um domínio de integridade 𝐷 e 𝐴,𝐵 ∈ 𝐷[𝑥] com 𝐵 = 0 ̸ e grau(𝐴) ≥ grau(𝐵), retorna res(𝐴,𝐵) e a SRP subresultante (𝑅0,𝑅1, . . . ,𝑅𝑘,0) de 𝐴 e 𝐵.
3: 𝑅0 ← 𝐴
4: 𝑅1 ← 𝐵
5: 𝑖 ← 1
6: 𝛾1 ← −1
7: 𝛿1 ← grau(𝐴) − grau(𝐵)
8: 𝛽1 ← (−1)𝛿1+1
9: enquanto 𝑅𝑖 ̸= 0 faça
10: 𝑟𝑖 ← cl(𝑅𝑖)
11: (𝑄,𝑅) ← PolyPseudoDivide(𝑅𝑖−1,𝑅𝑖)
12: 𝑅𝑖+1 ← 𝑅/𝛽𝑖 ◁ esta divisão é sempre exata
13: 𝑖 ← 𝑖 + 1
14: 𝛾𝑖(−𝑟𝑖−1) 𝛿𝑖−1 𝛾 1−𝛿𝑖−1 𝑖−1
15: 𝛿𝑖 ← grau(𝑅𝑖−1) − grau(𝑅𝑖)
16: 𝛽𝑖 ← −𝑟𝑖−1𝛾 𝛿𝑖 𝑖
17: fim enquanto
18: 𝑘 ← 𝑖 − 1
19: se grau(𝑅𝑘) > 0 então
20: devolve (0,(𝑅0,𝑅1, · · · ,𝑅𝑘,0))
21: fim se
22: se grau(𝑅𝑘−1) = 1 então
23: devolve (𝑅𝑘,(𝑅0,𝑅1, · · · ,𝑅𝑘,0))
24: fim se
25: 𝑠 ← 1 ◁ 𝑠 será (−1)𝜎𝑘
26: 𝑐 ← 1 ◁ 𝑠𝑅grau(𝑅𝑘−1)−1 𝑘 𝑐 será 𝜏𝑘
27: para 𝑗 ← 1 até 𝑘 − 1 faça ◁ computa 𝜏𝑘𝑅𝑘
28: se grau(𝑅𝑗−1) for ímpar e grau(𝑅𝑗 ) for ímpar então
29: 𝑠 ← −𝑠
30: fim se
31: 𝑐 ← 𝑐(𝛽𝑗/𝑟1+𝛿𝑗 𝑗 ) grau(𝑅𝑗 ) 𝑟 grau(𝑅𝑗−1)−grau(𝑅𝑗+1) 𝑗 ◁ divisão exata
32: fim para
33: devolve (𝑠𝑐𝑅grau(𝑅𝑘−1) 𝑘 ,(𝑅0,𝑅1 . . . ,𝑅𝑘,0))
34: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SubRes(A,B,x):=
block([R,i,gamma,delta,Res, beta,pq,pr,r,k,s,c,j,Ans],
    algebraic:true,
    R:[],
    gamma:[],
    delta:[],
    beta:[],
    r:[],
    push(Group(B,x),R),
    push(Group(A,x),R),
    i:2,
    push(-1,gamma),
    push(hipow(R[1],x)-hipow(R[2],x),delta),
    push((-1)^(delta[1]+1),beta),
    while R[i]#0 do (
        r:endcons(LC(R[i],x),r),
        [pq,pr]:PPsDiv(R[i-1],R[i],x),
        R:endcons(Group(pr/beta[i-1],x),R),
        gamma:endcons((-r[i-1])^delta[i-1]*gamma[i-1]^(1- delta[i-1]),gamma),
        delta:endcons(hipow(R[i],x)-hipow(R[i+1],x),delta),
        beta:endcons(-r[i-1]*gamma[i]^delta[i],beta),
        i:i+1
    ),
    k:i-1,
    if hipow(R[k],x)>0 then (
        Ans:[0,rest(R,-1)],
        algebraic:false,
        return(Ans)
    ),
    if hipow(R[k-1],x)=1 then (
        Ans:[R[k],rest(R,-1)],
        algebraic:false,
        return(Ans)
    ),
    s:1,
    c:1,
    for j:1 thru k-2 do (
        if mod(hipow(R[j],x),2)=1 and mod(hipow(R[j+1],x),2)=1 then s:-s,
        c:c*(beta[j]/r[j]^(1+delta[j]))^hipow(R[j+1],x) *r[j]^(hipow(R[j],x)-hipow(R[j+2],x))
    ),
    Res:s*c*R[k]^(hipow(R[k-1],x)),
    Ans:[Res,rest(R,-1)],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Normaliza o mdc entre dois polinômios para que seu coeficiente líder seja congruente a 1 mod 𝑃(𝑧).
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Normalize(A,x,P,z):=
block([a,mult,Ans],
    algebraic:true,
    mult:HExGCD(LC(A,x),P,z)[1],
    a:mult*A,
    a:PDiv(a,P,z)[2],
    a:content(Group(a,x))[2],
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O mesmo que a função factor do Maxima, porém retorna uma lista com os fatores da fatoração prima do polinômio 𝑄, ao invés de um produto. 𝑒𝑥𝑝𝑎 deve ter valor 𝑡𝑟𝑢𝑒 caso se deseje expandir os fatores.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LFactor(Q,x,expa):=
block([fac,l,i,c,q,listfac,Ans],
    algebraic:true,
    listfac:[],
    if hipow(Q,x)=0 then (
        Ans:[Q],
        algebraic:false,
        return(Ans)
    ),
    [c,q]:content(Q,x),
    q:Group(q,x),
    fac:factor(q),
    fac:2*fac^3,
    if op(fac)="-" then (
        c:-c,
        fac:-fac
    ),
    l:length(fac),
    push(c,listfac),
    for i:2 thru l do (
        listfac:endcons(second(fac)^(1/3),listfac),
        fac:fac/second(fac),
        if expa then listfac[i]:Group(listfac[i],x)
    ),
    Ans:listfac,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Fatoração livre de quadrados pelo algoritmo de Yun.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função SquareFree(𝐴)
2: descrição: Dado um domínio de fatoração única 𝐷 com característica 0 e 𝐴 ∈ 𝐷[𝑥], retorna 𝐴1, . . . ,𝐴𝑚 ∈ 𝐷[𝑥] tais que 𝐴 = ∏︁𝑚 𝑘=1 𝐴 𝑘 𝑘 é uma fatoração livre de quadrados de 𝐴.
3: 𝑐 ← cont(𝐴)
4: 𝑆 ← 𝐴/𝑐 ◁ 𝑆 = pp(𝐴)
5: 𝑆 ′ ← 𝑑𝑆/𝑑𝑥
6: 𝑆 − ← mdc(𝑆,𝑆′ )
7: 𝑆 * ← 𝑆/𝑆−
8: 𝑌 ← 𝑆 ′ /𝑆−
9: 𝑘 ← 1
10: enquanto (𝑍 ← 𝑌 − 𝑑𝑆* /𝑑𝑥) ̸= 0 faça ◁ 𝑆* = 𝐴 −𝑘−1 * , 𝑌 ← 𝑌𝑘
11: 𝐴𝑘 ← mdc(𝑆 * ,𝑍) ◁ (2.12)
12: 𝑆 * ← 𝑆 * /𝐴𝑘 ◁ 𝑆* = 𝐴 −𝑘 *
13: 𝑌 ← 𝑍/𝐴𝑘 ◁ 𝑌 = 𝑌𝑘+1
14: 𝑘 ← 𝑘 + 1
15: fim enquanto
16: 𝐴𝑘 ← 𝑆 *
17: devolve (𝑐𝐴1, . . . ,𝐴𝑘)
18: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SQFR(A,x):=
block([S,Sd,Sf,Y,fac,Z,k,c,dS,Ans],
    algebraic:true,
    fac:[],
    [c,S]:content(A,x),
    dS:Group(diff(S,x),x),
    Sd:GCD(S,dS,x,0,0),
    Sf:Group(S/Sd,x),
    Y:Group(dS/Sd,x),
    Z:Group(Y-diff(Sf,x),x),
    k:1,
    while Z#0 do (
        fac:endcons(GCD(Sf,Z,x,0,0),fac),
        Sf:Group(Sf/fac[k],x),
        Y:Group(Z/fac[k],x),
        Z:Group(Y-diff(Sf,x),x),
        k:k+1
    ),
    fac:endcons(Sf,fac),
    fac[1]:Group(c*fac[1],x),
    Ans:fac,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Decomposição em frações parciais simples.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função PartialFraction(𝑎,𝑑1, . . . ,𝑑𝑛)
2: descrição: Dado um domínio euclidiano 𝐷 e 𝑎,𝑑1, . . . ,𝑑𝑛 ∈ 𝐷 ∖ {0} com mdc(𝑑𝑖 ,𝑑𝑗 ) = 1 para 𝑖 ̸= 𝑗, retorna 𝑎0,𝑎1, . . . ,𝑎𝑛 ∈ 𝐷 tais que 𝑎 𝑑1 · · · 𝑑𝑛 = 𝑎0 + ∑︁𝑛 𝑖=1 𝑎𝑖 𝑑𝑖 com 𝑎𝑖 = 0 ou 𝜈(𝑎𝑖) < 𝜈(𝑑𝑖) para 𝑖 ≥ 1.
3: (𝑎0,𝑟) ← EuclideanDivision(𝑎,𝑑1, . . . ,𝑑𝑛) ◁ 𝑎 = (𝑑1 · · · 𝑑𝑛)𝑎0 + 𝑟
4: se 𝑛 = 1 então
5: devolve (𝑎0,𝑟)
6: fim se
7: (𝑎1,𝑡) ← ExtendedEuclidean(𝑑2 · · · 𝑑𝑛,𝑑1,𝑟) ◁ 𝜈(𝑎1) < 𝜈(𝑑1)
8: (𝑏0,𝑎2, . . . ,𝑎𝑛) ← PartialFraction(𝑡,𝑑2, . . . ,𝑑𝑛)
9: devolve (𝑎0 + 𝑏0,𝑎1,𝑎2, . . . ,𝑎𝑛)
10: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PFrac(A,Fac,x):=
block([fac,len,Den,a,a0,r,aux,t,Ans],
    algebraic:true,
    a:makelist(0,1),
    fac:copylist(Fac),
    len:length(fac),
    Den:product(fac[i],i,1,len),
    [a0,r]:PDiv(A,Den,x),
    if len=1 then (
        Ans:[a0,r],
        algebraic:false,
        return(Ans)
    ),
    Den:Den/fac[1],
    [a[1],t]:DioHFExGCD(Den,fac[1],r,x),
    pop(fac),
    aux:PFrac(t,fac,x),
    push(aux[1],a),
    pop(aux),
    a:append(a,aux),
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão original da redução de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HermiteReduce(𝐴,𝐷)
2: descrição: Dado um corpo K e 𝐴,𝐷 ∈ K[𝑥] com 𝐷 não nulo e coprimo com 𝐴, retorna 𝑔,ℎ ∈ K(𝑥) tais que 𝐴/𝐷 = 𝑔 ′ + ℎ com ℎ possuindo um denominador livre de quadrados.
3: (𝐷1, . . . ,𝐷𝑚) ← SquareFree(𝐷)
4: (𝑃,𝐴1,𝐴2, . . . ,𝐴𝑛) ← PartialFraction(𝐴,𝐷1,𝐷2 2 , . . . ,𝐷𝑛 𝑛 )
5: 𝑔 ← 0
6: ℎ ← 𝑃 + 𝐴1/𝐷1
7: para 𝑘 ← 2 até 𝑛 tal que grau(𝐷𝑘) > 0 faça
8: 𝑉 ← 𝐷𝑘
9: para 𝑗 ← 𝑘 − 1 até 1 passo −1 faça
10: (𝐵,𝐶) ← ExtendedEuclidean(𝑉 ′ ,𝑉, − 𝐴𝑘/𝑗)
11: 𝑔 ← 𝑔 + 𝐵/𝑉 𝑗
12: 𝐴𝑘 ← −𝑗𝐶 − 𝐵 ′
13: fim para 
14: ℎ ← ℎ + 𝐴𝑘/𝑉
15: fim para
16: devolve (𝑔,ℎ)
17: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermO(A,D,x):=
block([SF,SFExp,PF,g,h,k,V,dV,B,C,j,n,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    SF:SQFR(D,x),
    n:length(SF),
    SFExp:makelist(SF[i]^i,i,1,n),
    PF:PFrac(A,SFExp,x),
    g:0,
    h:PF[1]+fullratsimp(PF[2])/SF[1],
    for k:2 thru n do (
        if hipow(SF[k],x)>0 then (
            V:SF[k],
            dV:diff(V,x),
            for j:k-1 thru 1 step -1 do (
                [B,C]:DioHFExGCD(dV,V,-expand (fullratsimp(PF[k+1]/j)),x),
                g:g+fullratsimp(B)/V^j,
                PF[k+1]:-j*C-diff(B,x)
            ),
            h:h+fullratsimp(PF[k+1])/V
        )
    ),
    Ans:[g,h],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão quadrática da redução de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HermiteReduce(𝐴,𝐷)
2: descrição: Dado um corpo K e 𝐴,𝐷 ∈ K[𝑥] com 𝐷 não nulo e coprimo com 𝐴, retorna 𝑔,ℎ ∈ K(𝑥) tais que 𝐴/𝐷 = 𝑔 ′ + ℎ com ℎ possuindo um denominador livre de quadrados.
3: 𝑔 ← 0
4: (𝐷1, . . . ,𝐷𝑚) ← SquareFree(𝐷)
5: para 𝑖 ← 2 até 𝑚 tal que grau(𝐷𝑖) > 0 faça
6: 𝑉 ← 𝐷𝑖
7: 𝑈 ← 𝐷/𝑉 𝑖
8: para 𝑗 ← 𝑖 − 1 até 1 passo −1 faça
9: (𝐵,𝐶) ← ExtendedEuclidean(𝑈𝑉 ′ ,𝑉, − 𝐴/𝑗)
10: 𝑔 ← 𝑔 + 𝐵/𝑉 𝑗
11: 𝐴 ← −𝑗𝐶 − 𝑈𝐵′
12: fim para
13: 𝐷 ← 𝑈𝑉
14: fim para
15: devolve (𝑔,𝐴/𝐷)
16: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermQ(A,D,x):=
block([SF,SFExp,a,d,g,h,k,V,dV,U,B,C,j,n,Ans],
    algebraic:true,
    a:A,
    d:D,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    g:0,
    SF:SQFR(D,x),
    n:length(SF),
    for k:2 thru n do (
        if hipow(SF[k],x)>0 then (
            V:SF[k],
            dV:expand(diff(V,x)),
            U:expand(fullratsimp(d/V^k)),
            for j:k-1 thru 1 step -1 do (
                [B,C]:DioHFExGCD(expand(U*dV), V,-expand(fullratsimp(a/j)),x),
                g:g+fullratsimp(B)/V^j,
                a:expand(fullratsimp(-j*C-U*diff(B,x)))
            ),
            d:U*V)
    ),
    Ans:[g,fullratsimp(a)/d],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Versão linear da redução de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HermiteReduce(𝐴,𝐷)
2: descrição: Dado um corpo K e 𝐴,𝐷 ∈ K[𝑥] com 𝐷 não nulo e coprimo com 𝐴, retorna 𝑔,ℎ ∈ K(𝑥) tais que 𝐴/𝐷 = 𝑔 ′ + ℎ com ℎ possuindo um denominador livre de quadrados.
3: 𝑔 ← 0
4: 𝐷 − ← mdc(𝐷,𝐷′ )
5: 𝐷 * ← 𝐷/𝐷−
6: enquanto grau(𝐷 −) > 0 faça
7: 𝐷 −2 ← mdc(𝐷 −,𝐷−′ )
8: 𝐷 −* ← 𝐷 −/𝐷−2
9: (𝐵,𝐶) ← ExtendedEuclidean(−𝐷 *𝐷 −′ /𝐷−,𝐷−* ,𝐴)
10: 𝐴 ← 𝐶 − 𝐵 ′𝐷 * /𝐷−* ◁ novo numerador
11: 𝑔 ← 𝑔 + 𝐵/𝐷−
12: 𝐷 − ← 𝐷 −2 ◁ 𝐷 − = 𝐷 −2
13: fim enquanto
14: devolve (𝑔,𝐴/𝐷* )
15: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermL(A,D,x):=
block([a,Dd,Dd2,Df,Ddf,degDd,dDd,g,B,C,Ans],
    algebraic:true,
    a:A,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    g:0,
    Dd:GCD(D,diff(D,x),x,0,0),
    Df:Group(D/Dd,x),
    degDd:hipow(Dd,x),
    while degDd>0 do (
        dDd:Group(diff(Dd,x),x),
        Dd2:GCD(Dd,dDd,x,0,0),
        Ddf:Group(Dd/Dd2,x),
        [B,C]:DioHFExGCD(Group(-Df*dDd /Dd,x),Ddf,a,x),
        a:Group(C-diff(B,x)*Df/Ddf,x),
        g:g+fullratsimp(B)/Dd,
        Dd:Dd2,
        degDd:hipow(Dd,x)
    ),
    Ans:[g,fullratsimp(a)/Df],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Método de Horowitz-Ostrogradsky.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HorowitzOstrogradsky(𝐴,𝐷)
2: descrição: Dado um corpo K e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 não nulo e coprimo com 𝐴, retorna 𝑔,ℎ ∈ K(𝑥) tais que 𝐴/𝐷 = 𝑔 ′ + ℎ com ℎ possuindo um denominador livre de quadrados.
3: 𝐷 − ← mdc(𝐷,𝐷′ )
4: 𝐷 * ← 𝐷/𝐷−
5: 𝑛 ← grau(𝐷 −) − 1
6: 𝑚 ← grau(𝐷 * ) − 1
7: 𝑑 ← grau(𝐷)
8: 𝐵 ← ∑︁𝑛 𝑖=0 𝑏𝑖𝑥 𝑖
9: 𝐶 ← ∑︁𝑚 𝑗=0 𝑐𝑗𝑥 𝑗
10: 𝐻 ← 𝐴 − 𝐵 ′𝐷 * + 𝐵𝐷*𝐷 −′ /𝐷− − 𝐶𝐷− ◁ divisão exata
11: (𝑏0, . . . ,𝑏𝑛,𝑐0, . . . ,𝑐𝑛) ← solucionador(coeficiente(𝐻,𝑥𝑘 ) = 0,0 ≤ 𝑘 ≤ 𝑑)
12: devolve ∑︁𝑛 𝑖=0 𝑏𝑖𝑥 𝑖 /𝐷−, ∑︁𝑚 𝑖=0 𝑐𝑗𝑥 𝑗 /𝐷*
13: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HorOstro(A,D,x):=
block([a,Dd,Df,dDd,n,m,d,C,B,dB,H,j,b,c,k,eq,listb, listc,listvar,sol,Rac,Log,Ans],
    algebraic:true,
    a:A,
    eq:[],
    linsolvewarn:false,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    Dd:GCD(D,diff(D,x),x,0,0),
    if Dd=1 then (
        Ans:[0,A/D],
        algebraic:false,
        return(Ans)
    ),
    dDd:diff(Dd,x),
    Df:Group(D/Dd,x),
    n:hipow(Dd,x),
    m:hipow(Df,x),
    d:m+n-1,
    B:sum(b[i]*x^(i-1),i,1,n),
    C:sum(c[i]*x^(i-1),i,1,m),
    dB:expand(diff(B,x)),
    H:Group(A-dB*Df+B*Df*dDd/Dd-C*Dd,x),
    for k:0 thru d do eq:endcons(coeff(H,x,k)=0,eq),
    listb:makelist(b[i],i,1,n),
    listc:makelist(c[i],i,1,m),
    listvar:append(listb,listc),
    sol:solve(eq,listvar)[1],
    Rac:fullratsimp(sum(rhs(sol[i])*x^(i-1),i,1,n))/Dd,
    Log:fullratsimp(sum(rhs(sol[i])*x^(i-1-n),i,n+1,n+m))/Df,
    Ans:[Rac,Log],
    algebraic:false,
    linsolvewarn:true,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Bernoulli. Esta versão é aplicada a funções com denominadores livres de quadrados. Além disso, é independente: diferente das demais funções desta seção, fornece diretamente a parte logarítmica e as funções arco tangente, efetivamente terminando a integração. Este código também prevê representações inertes das extensões, as quais são dadas sempre em termos das raízes do denominador, isto é, utilizando-se a fórmula dos resíduos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Bern(A,D,x,mode,solvemethod):=
block([fac,sols,a,dD,gamma,Log,ILog,Atan, pol,rea,ima,Num,expl,S,T,P,Q,Ans],
    algebraic:true,
    Log:0,
    ILog:0,
    Atan:0,
    dD:diff(D,x),
    if mode=real then (
        [P,Q]:Parts(A,x),
        [S,T]:Parts(dD,x),
        C1(a,b):=fullratsimp(subst(a,u,subst(b,v,(P*S+Q*T)/ (S^2+T^2)))),
        C2(a,b):=fullratsimp(subst(a,u,subst(b,v,(P*T-Q*S)/ (S^2+T^2))))
    ),
    fac:LFactor(D,x,false),
    sols:Solve(fac,x,solvemethod),
    sols:RHS(sols),
    for i:1 thru length(sols) do (
        a:sols[i],
        if hipow(a,x)=0 then (
            if mode=complex then (
                gamma:fullratsimp(subst(a,x,A/dD)),
                Log:Log+gamma*log(x-a)
            ),
            if mode=real then (
                rea:fullratsimp(realpart(a)),
                ima:fullratsimp(imagpart(a)),
                if ima=0 then (
                    gamma:fullratsimp(subst(rea,x,A/dD)),
                    Log:Log+gamma*log(x-rea)
                ),
                if ima>0 then (
                    pol:Group(x^2-fullratsimp(2*rea)*x +fullratsimp(rea^2+ima^2),x),
                    Log:Log+C1(rea,ima)*log(pol),
                    Atan:Atan+2*C2(rea,ima)*atan( fullratsimp((x-rea)/ima)),
                    Atan:fullratsimp(Atan)
                )
            )
        ) else (
            expl:PDiv(D,a,x)[1],
            Num:last(PFrac(A,[expl,a],x)),
            ILog:ILog+'lsum(subst(%alpha,x,fullratsimp(Num) /diff(a,x))*log(x-%alpha),%alpha,RootsOf(a))
        )
    ),
    Ans:[Log,Atan,ILog],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rothstein-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função IntRationalLogPart(𝐴,𝐷)
2: descrição: Dado um corpo K de característica 0 e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 não nulo, livre de quadrados e coprimo com 𝐴, retorna ∫ 𝐴/𝐷. 3: 𝑧 ← uma nova indeterminada sobre K
4: 𝑅 ← res𝑥(𝐷,𝐴 − 𝑧𝐷′ )
5: 𝑢𝑅𝑒1 1 · · · 𝑅 𝑒𝑚 𝑚 ← factoração(𝑅) ◁ fatoração em fatores irredutíveis
6: para 𝑖 ← 1 até 𝑚 faça
7: 𝑎 ← 𝑎 | 𝑅𝑖(𝑎) = 0
8: 𝐺𝑖 ← mdc(𝐷,𝐴 − 𝑎𝐷′ ) ◁ computação algébrica de mdc
9: fim para
10: devolve ∑︁𝑚 𝑖=1 ∑︁ 𝑎|𝑅𝑖(𝑎)=0 𝑎 log(𝐺𝑖)
11: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RothTra(A,D,x):=
block([k,expr,%Z,R,dD,Q,S,Ans],
    algebraic:true,
    Q:[],
    S:[],
    if hipow(D,x)=1 then (
        Ans:[[%Z-A/LC(D,x)],[Mon(D,x)]],
        algebraic:false,
        return(Ans)
    ),
    dD:expandwrt(diff(D,x),x),
    expr:Group(A-%Z*dD,x),
    R:content(SubRes(D,A-%Z*dD,x)[1])[2],
    Q:LFactor(R,%Z,false),
    Q:rest(Q),
    for i:1 thru length(Q) do (
        Q[i]:Q[i]^2,
        Q[i]:Group(first(Q[i]),%Z),
        S:endcons(GCD(D,expr,x,Q[i],%Z),S),
        S[i]:Normalize(S[i],x,Q[i],%Z)
    ),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Lazard-Rioboo-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função IntRationalLogPart(𝐴,𝐷)
2: descrição: Dado um corpo K de característica 0 e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 não nulo, livre de quadrados e coprimo com 𝐴, retorna ∫ 𝐴/𝐷. 3: 𝑧 ← uma nova indeterminada sobre K
4: (𝑅,(𝑅0,𝑅1, . . . ,𝑅𝑘,0)) ← SubResultant𝑥(𝐷,𝐴 − 𝑧𝐷′ )
5: (𝑄1, . . . ,𝑄𝑛) ← SquareFree(𝑅)
6: para 𝑖 ← 1 até 𝑛 tal que grau𝑧 (𝑄𝑖) > 0 faça
7: se 𝑖 = grau(𝐷) então
8: 𝑆𝑖 ← 𝐷
9: senão
10: 𝑆𝑖 ← 𝑅𝑚 onde grau𝑥 (𝑅𝑚) = 𝑖, 1 ≤ 𝑚 ≤ 𝑘
11: (𝐴1, . . . ,𝐴𝑞) ← SquareFree(lc𝑥(𝑆𝑖))
12: para 𝑗 ← 1 até 𝑞 faça
13: 𝑆𝑖 ← 𝑆𝑖/ mdc(𝐴𝑗 ,𝑄𝑖) 𝑗 ◁ divisão exata
14: fim para
15: fim se
16: fim para
17: devolve ∑︁𝑛 𝑖=1 ∑︁ 𝑎|𝑄𝑖(𝑎)=0 𝑎 log(𝑆𝑖(𝑎,𝑥))
18: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LaRiTra(A,D,x):=
block([%Z,Q,R,seqR,S,degSi,lcSi,dD, k,n,q,lcSi,i,j,j1,listA,Ans],
    algebraic:true,
    dD:expand(diff(D,x)),
    R:SubRes(D,Group((A-%Z*dD),x),x),
    R[1]:Group(R[1],%Z),
    seqR:R[2],
    k:length(seqR),
    Q:SQFR(content(R[1],%Z)[2],%Z),
    n:length(Q),
    S:makelist(1,n),
    for i:1 thru n do (
        if hipow(Q[i],%Z)>0 then (
            if i=hipow(D,x) then (
                S[i]:D
            ) else (
                for j:1 thru k do (
                    if hipow(seqR[j],x)=i then (
                        S[i]:seqR[j]
                    )
                ),
                degSi:hipow(S[i],x),
                lcSi:coeff(S[i],x,degSi),
                listA:SQFR(lcSi,%Z),
                q:length(listA),
                for j1:1 thru q do (
                    S[i]:fullratsimp(S[i]/GCD(listA[j1], Q[i],t,0,0)^j1,%Z)
                )
            )
        ),
        S[i]:Group(S[i],x)
    ),
    for i:1 thru length(Q) do (
        if hipow(Q[i],%Z)=0 then (
            Q[i]:1 
        ) else (
            S[i]:Group(PDiv(S[i],Q[i],%Z)[2],x),
            S[i]:Normalize(S[i],x,Q[i],%Z)
        )
    ),
    Q:delete(1,Q),
    S:delete(1,S),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O algoritmo de Czichowski, o qual calcula a parte logaítmica da integral de uma função racional, da mesma forma que os algoritmos de Rothstein-Trager e Lazard-Rioboo-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função IntRationalLogPart(𝐴,𝐷)
2: descrição: Dado um corpo K de característica 0 e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 não nulo, livre de quadrados e coprimo com 𝐴, retorna ∫ 𝐴/𝐷. 3: ◁ Cálculo da base Gröbner reduzida
4: (𝑃1, . . . ,𝑃𝑚) ← ReducedGröbner(𝐷,𝐴 − 𝑧𝐷′ , olp, 𝑥 > 𝑧)
5: ◁ (𝑃1, . . . ,𝑃𝑚) deve ter ordem crescente nos maiores termos
6: para 𝑖 ← 1 até 𝑚 − 1 faça
7: 𝑄𝑖 ← cont𝑥(𝑃𝑖)/ cont𝑥(𝑃𝑖+1) ◁ divisão exata
8: 𝑆𝑖 ← pp𝑥 (𝑃𝑖)
9: fim para
10: devolve 𝑚∑︁−1 𝑖=1 ∑︁ 𝑎|𝑄𝑖(𝑎)=0 𝑎 log(𝑆𝑖(𝑎,𝑥))
11: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
load(grobner)$
Czi(A,D,x):=
block([P,dD,m,i,Q,S,Ans],
    algebraic:true,
    P:[],
    Q:[],
    S:[],
    dD:expand(diff(D,x)),
    P:poly_reduced_grobner([D,expandwrt(A-%Z*dD,x)],[x,%Z]),
    P:sort(P),
    m:length(P),
    for i:1 thru m-1 do (
        Q:endcons(expandwrt(fullratsimp(content(P[i],x)[1] /content(P[i+1],x)[1]),%Z),Q),
        S:endcons(content(P[i+1],x)[2],S)
    ),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de clássico para obtenção de arcos tangentes.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Classic(A,B,x):=
block([Ans],
    algebraic:true,
    Ans:2*atan(fullratsimp(A/B)),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rioboo — caso complexo.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função LogToAtan(𝐴,𝐵)
2: descrição: Dado um corpo K de característica 0 tal que 𝐼 /∈ K, e 𝐴,𝐵 ∈ K[𝑥] com 𝐵 ̸= 0, retorna uma soma 𝑓 de funções arco tangente de polinômios em K[𝑥] tais que 𝑑𝑓 𝑑𝑥 = 𝑑 𝑑𝑥𝐼 log (︂𝐴 + 𝐼𝐵 𝐴 − 𝐼𝐵 )︂ .
3: se 𝐵 | 𝐴 então
4: devolve 2 arctg(𝐴/𝐵)
5: fim se
6: se grau(𝐴) < grau(𝐵) então
7: devolve LogToAtan(−𝐵,𝐴)
8: fim se
9: (𝐷,𝐶,𝐺) ← ExtendedEuclidean(𝐵, − 𝐴) ◁ 𝐵𝐷 − 𝐴𝐶 = 𝐺
10: devolve 2 arctg((𝐴𝐷 + 𝐵𝐶)/𝐺) + LogToAtan(𝐷,𝐶)
11: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Rioboo(A,B,x):=
block([a,b,D,C,G,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    if PDiv(a,b,x)[2]=0 then (
        algebraic:false,
        return(2*atan(Group(a/b,x)))
    ),
    if hipow(a,x)<hipow(b,x) then (
        algebraic:false,
        return(Rioboo(-b,a,x))
    ),
    [D,C,G]:HFExGCD(b,-a,x),
    Ans:2*atan(Group((a*D+b*C)/G,x))+Rioboo(D,C,x),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rioboo — caso geral.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Rioboo2(A,B,alpha,x,N):=
block([a,b,D,C,G,n,pol,Ans],
    algebraic:true,
    if N=0 then (
        Ans:alpha*log(A+alpha*B)-alpha*log(A-alpha*B),
        algebraic:false,
        return(Ans)
    ),
    a:Group(A,x),
    b:Group(B,x),
    if PDiv(a,b,x)[2]=0 then (
        pol:PDiv(Group(a/(alpha*b),x),alpha,x)[1],
        Ans:ratsimp(2*alpha*atanh(alpha*pol)),
        algebraic:false,
        return(Ans)
    ),
    if hipow(a,x)<hipow(b,x) then (
        Ans:Rioboo2(alpha^2*b,a,alpha,x,N),
        algebraic:false,
        return(Ans)
    ),
    [D,C,G]:HFExGCD(b,-a,x),
    n:N-1,
    pol:ratsimp(PDiv(Group((a*D-alpha^2*b*C)/(alpha*G),x), alpha,x)[1]),
    Ans:2*alpha*atanh(alpha*pol)+Rioboo2(D,C,alpha,x,n),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente inerte. Dado um polinômio irredutível 𝑃, retorna a lista [0 = 𝑃].
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
NoSolve(P,x):=
block([Ans],
    algebraic:true,
    Ans:[0=P],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente de domínio. Dado um polinômio irredutível 𝑃, resolve-o se ele puder se escrito na forma 𝑃(𝑥) = 𝑎𝑥 + 𝑏, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DomSolve(P,x):=
block([sols,Ans],
    algebraic:true,
    sols:NoSolve(P,x),
    if hipow(P,x)=1 then (
        Ans:solve(P,x),
        algebraic:false,
        return(Ans)
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente linear. Dado um polinômio irredutível 𝑃, resolve-o se ele puder se escrito na forma 𝑃(𝑥) = 𝑎𝑥𝑛 + 𝑏, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LinSolve(P,x):=
block([sols,aux,Ans],
    algebraic:true,
    sols:DomSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if hipow(aux,x)=lopow(aux,x) then (
            Ans:solve(P,x),
            algebraic:false,
            return(Ans)
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente quadrático. Dado um polinômio irredutível 𝑃, resolve-o se ele puder se escrito na forma 𝑃(𝑥) = 𝑎𝑥2𝑛 + 𝑏𝑥𝑛 + 𝑐, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
QuadSolve(P,x):=
block([degP,sols,aux,Ans],
    algebraic:true,
    sols:LinSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if length(aux)=2 then (
            degP:hipow(P,x),
            if mod(degP,2)=0 then (
                if (coeff(P,x,degP/2))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente cúbico. Dado um polinômio irredutível 𝑃, resolve-o se ele puder se escrito na forma 𝑃(𝑥) = 𝑎𝑥3𝑛 + 𝑏𝑥𝑛 + 𝑐, 𝑃(𝑥) = 𝑎𝑥3𝑛 + 𝑏𝑥2𝑛 + 𝑐, ou 𝑃(𝑥) = 𝑎𝑥3𝑛 + 𝑏𝑥2𝑛 + 𝑐𝑥𝑛 + 𝑑, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
CubeSolve(P,x):=
block([degP,sols,aux,Ans],
    algebraic:true,
    sols:QuadSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if length(aux)=2 then (
            degP:hipow(P,x),
            if mod(degP,3)=0 then (
                if (coeff(P,x,degP/3))#0 or (coeff(P,x,2*degP/3))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        ),
        if length(aux)=3 then (
            degP:hipow(P,x),
            if mod(degP,3)=0 then (
                if (coeff(P,x,degP/3))#0 and (coeff(P,x,2*degP/3))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente geral. 𝑓 𝑎𝑐 é uma lista de fatores de 𝑃 na variável 𝑥 obtida utilizando-se a função ListFactor. A função encontra cada uma das raízes de 𝑃 utilizando o método 𝑚𝑒𝑡ℎ𝑜𝑑 em cada um de seus fatores irredutíveis. 𝑚𝑒𝑡ℎ𝑜𝑑 pode ser: NoSolve, DomSolve, LinSolve, QuadSolve, CubeSolve ou solve, esta última sendo o solvente nativo do Máxima.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Solve(fac,x,method):=
block([P,l,i,solsfac,sols,unsolved,Ans],
    algebraic:true,
    l:length(fac),
    sols:[],
    unsolved:1,
    if l=1 then (
        algebraic:false,
        error("polynomial is constant or 0.")
    ),
    for i:2 thru l do (
        P:fac[i]^2,
        P:first(P),
        P:Group(P,x),
        solsfac:method(P,x),
        if lhs(last(solsfac))=0 then unsolved:unsolved*rhs(last(solsfac)) else sols:append(sols,solsfac)
    ),
    if unsolved=1 then (
        Ans:sols,
        algebraic:false,
        return(Ans)
    ) else (
        Ans:append(sols,[0=unsolved]),
        algebraic:false,
        return(Ans)
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Converte uma lista cujos elementos são da forma 𝑙ℎ𝑠 = 𝑟ℎ𝑠 em uma lista cujos elementos são da forma 𝑟ℎ𝑠. Essa função se aplica a listas de soluções de um polinômio.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RHS(sols):=
block([consts,i,Ans],
    algebraic:true,
    consts:[],
    for i:1 thru length(sols) do consts:endcons(rhs(sols[i]),consts),
    Ans:consts,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Dada uma lista de números complexos, retorna uma lista cujos elementos são da forma [𝑎,𝑏], com 𝑎,𝑏 ∈ R, 𝑏 > 0 e tais que 𝑎+𝐼𝑏 pertence à lista original. Aplica-se ao sistema não linear que surge na discussão do algoritmo de Rioboo.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SolveSys(compl):=
block([a,b,j,sols,Ans],
    algebraic:true,
    sols:[],
    for j:1 thru length(compl) do (
        a:fullratsimp(realpart(compl[j])),
        b:fullratsimp(imagpart(compl[j])),
        if b>0 then (
            sols:endcons([a,b],sols)
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Dada uma lista de fatores 𝑅 na variável 𝑧 resolve cada um dos fatores utilizando o método 𝑠𝑜𝑙𝑣𝑒𝑚𝑒𝑡ℎ𝑜𝑑 e armazena, respectivamente, nas listas 𝑟𝑒𝑖 , 𝑐𝑜𝑚𝑝𝑙𝑖 e 𝑖𝑛𝑒𝑟𝑡𝑖 as soluções reais, contendo unidade imaginária e o que não pôde ser resolvido do fator 𝑅𝑖 . Utilizada para encontrar as extensões que devem aparecer na expressão final da integral de uma função racional.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Extensions(R,z,solvemethod):=
block([l,i,j,exts,re,compl,inert,fac,Ans],
    algebraic:true,
    l:length(R),
    re:[],
    compl:[],
    inert:[],
    for i:1 thru l do (
        fac:LFactor(R[i],z,false),
        exts:RHS(Solve(fac,z,solvemethod)),
        re:endcons([],re),
        compl:endcons([],compl),
        inert:endcons([],inert),
        for j:1 thru length(exts) do (
            if hipow(exts[j],z)#0 then inert[i]:endcons(exts[j],inert[i]) else if imagpart(exts[j])#0 then compl[i]:endcons(exts[j],compl[i]) else re[i]:endcons(exts[j],re[i])
        )
    ),
    Ans:[re,compl,inert],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Verifica se todos os elementos da lista 𝑠𝑜𝑙𝑠 possuem apenas elementos racionais em alguma das duas coordenadas. A resposta é um vetor booleano de dois elementos. O valor 𝑡𝑟𝑢𝑒 indica que todas os elementos das coordenadas correspondentes são racionais.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
VerifyRatSols(sols):=
block([i,signal1,signal2,a,b,Ans],
    algebraic:true,
    signal1:true,
    signal2:true,
    for i:1 thru length(sols) do (
        a:sols[i][1],
        b:sols[i][2],
        if (integerp(num(a)) and integerp(denom(a)))=false then signa1:false,
        if (integerp(num(b)) and integerp(denom(b)))=false then signa2:false
    ),
    Ans:[signal1,signal2],
    algebraic:true,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Monta os logaritmos reais que aparecem na expressão final da integral, mas que não são obtidos a partir de extensões contendo unidade imaginária. Algumas conversões simples para funções arco tangente hiperbólico são realizadas quando temos a condição 𝐵(𝑎,𝑏,𝑥) | 𝐴(𝑎,𝑏,𝑥).
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RealLog(S,z,x,re,modei,atanhconv):=
block([i,j,RLog,Atanh,expl,SubS,Swap,a,b,M,m,A,B,q],
    algebraic:true,
    RLog:0,
    expl:1,
    Atanh:0,
    for i:1 thru length(S) do (
        if length(re[i])=2 and atanhconv=true and (re[i][1]=-re[i][2] or rationalp(re[i][1])=false) then (
            a:(re[i][1]+re[i][2])/2,
            b:abs(re[i][1]-re[i][2])/2,
            M:max(re[i][1],re[i][2]),
            m:min(re[i][1],re[i][2]),
            A:Group((subst(M,z,S[i])+subst(m,z,S[i]))/2,x),
            B:Group((subst(M,z,S[i])-subst(m,z,S[i]))/2,x),
            if hipow(A,x)<hipow(B,x) then (
                Swap:A,
                A:b^2*B,
                B:b*Swap
            ),
            [q,r]:PDiv(A,B,x),
            if r=0 then (
                SubS:fullratsimp(A^2-B^2),
                RLog:RLog+a*log(SubS),
                if modei=den then expl:expl*SubS,
                Atanh:Atanh+2*b*atanh(q)
            ) else (
                for j:1 thru 2 do (
                    a:fullratsimp(re[i][j]),
                    SubS:content(subst(a,z,S[i]),x)[2],
                    if modei=den then expl:expl*SubS,
                    SubS:Mon(SubS,x),
                    RLog:RLog+a*log(SubS)
                )
            )
        ) else (
            for j:1 thru length(re[i]) do (
                a:fullratsimp(re[i][j]),
                SubS:content(subst(a,z,S[i]),x)[2],
                if modei=den then expl:expl*SubS,
                SubS:Mon(SubS,x),
                RLog:RLog+a*log(SubS)
            )
        )
    ),
    RLog:ratsimp(RLog),
    Atanh:ratsimp(Atanh),
    Ans:[expl,RLog,Atanh],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Se não estivermos interessados em realizar conversões para arcos tangentes, esta função monta os logaritmos complexos que aparecem na expressão final da integral. Caso contrário, monta os logaritmos e funções arco tangente que surgem de extensões contendo unidades imaginárias. No caso real, resolve o sistema 𝑃(𝑢,𝑣) = 𝑄(𝑢,𝑣) encontrando diretamente as raízes complexas com parte imaginária positiva de 𝑅(𝑧).
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função LogToReal(𝑅,𝑆)
2: descrição: Dado um corpo K ⊆ R, 𝑅 ∈ K[𝑧] e 𝑆 ∈ K[𝑧,𝑥], retorna uma função real 𝑓 tal que 𝑑𝑓 𝑑𝑥 = 𝑑 𝑑𝑥 ∑︁ 𝛼|𝑅(𝛼)=0 𝛼 log(𝑆(𝛼,𝑥)).
3: Escreva 𝑅(𝑢 + 𝐼𝑣) = 𝑃(𝑢,𝑣) + 𝐼𝑄(𝑢,𝑣)
4: Escreva 𝑆(𝑢 + 𝐼𝑣,𝑥) = 𝐴(𝑢,𝑣,𝑥) + 𝐼𝐵(𝑢,𝑣,𝑥)
5: devolve ∑︁ 𝑎,𝑏∈R,𝑏>0 𝑃 (𝑎,𝑏)=𝑄(𝑎,𝑏)=0 𝑎 log(𝐴(𝑎,𝑏,𝑥) 2 + 𝐵(𝑎,𝑏,𝑥) 2 )+ 𝑏 LogToAtan(𝐴,𝐵)(𝑎,𝑏,𝑥) + ∑︁ 𝑎∈R,𝑅(𝑎)=0 𝑎 log(𝑆(𝑎,𝑥))
6: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ComplLog(S,R,z,x,expl,compl,mode,modei,atanmethod):=
block([i,j,k,a,b,x,u,v,CLog,Atan,Expl, SubS,SubA,SubB,A,B,sols,signal1,signal2,auxatan,Ans],
    algebraic:true,
    CLog:0,
    Atan:0,
    Expl:expl,
    if mode=complex then (
        for i:1 thru length(S) do (
            for j:1 thru length(compl[i]) do (
                a:fullratsimp(compl[i][j]),
                SubS:content(subst(a,z,S[i]),x)[2],
                if modei=den then Expl:Expl*SubS,
                SubS:Mon(SubS,x),
                CLog:CLog+a*log(SubS)
            )
        )
    ),
    if mode=real then (
        for i:1 thru length(S) do (
            if length(compl[i])>0 then (
                [SubA,SubB]:Parts(S[i],z),
                A(a,b,x):=subst(a,u,subst(b,v,SubA)),
                B(a,b,x):=subst(a,u,subst(b,v,SubB)),
                sols:SolveSys(compl[i]),
                [signal1,signal2]:VerifyRatSols(sols),
                if (signal1 or signal2)=false then (
                    auxatan:atanmethod(A(u,v,x),B(u,v,x),x)
                ),
                for j:1 thru length(sols) do (
                    a:sols[j][1],
                    b:sols[j][2],
                    SubS:content(A(a,b,x)^2+B(a,b,x)^2,x)[2],
                    SubS:Mon(SubS,x),
                    if modei=den then Expl:Expl*SubS,
                    CLog:CLog+a*log(SubS),
                    if signal1=false and signal2=true then (
                        auxatan:atanmethod(A(u,b,x), B(u,b,x),x)
                    ),
                    if signal1=true and signal2=false then (
                        auxatan:atanmethod(A(a,v,x), B(a,v,x),x)
                    ),
                    if signal1=true and signal2=true then (
                        auxatan:atanmethod(A(a,b,x), B(a,b,x),x)
                    ),
                    auxatan:subst(a,u,subst(b,v,auxatan)),
                    Atan:Atan+b*auxatan,
                    Atan:fullratsimp(Atan)
                )
            )
        )
    ),
    Ans:[Expl,CLog,Atan],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Monta as expressões inertes da integral. Se certos resíduos não puderam ser encontrados durante o processo de integração, então a porção da integral que depende deles é deixada na forma inerte, isto é, como uma soma de logaritmos sobre as raízes de um determinado polinômio.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
InertLog(S,z,x,h,inert,expl,modei):=
block([i,j,ILog,SubS,impl,Num,Ans],
    algebraic:true,
    ILog:0,
    if modei=den then (
        impl:Group(denom(h)/expl,x),
        if hipow(impl,x)=0 then (
            Ans:ILog,
            algebraic:false,
            return(Ans)
        ),
        Num:last(PFrac(num(h),[expl,impl],x)),
        ILog:'lsum(subst(%alpha,x,fullratsimp(Num)/ fullratsimp(diff(impl,x)))*log(x-%alpha), %alpha,RootsOf(content(impl,x)[2]))
    ),
    if modei=res then (
        for i:1 thru length(S) do (
            for j:1 thru length(inert[i]) do (
                SubS:PPsDiv(S[i],inert[i][j],z)[2],
                SubS:content(Group(subst(%gamma,z,SubS), x),x)[2],
                if integerp(LC(SubS,x)) then SubS:Mon(SubS,x),
                ILog:ILog+'lsum(%gamma*log(SubS),%gamma, RootsOf(inert[i][j]))
            )
        )
    ),
    Ans:ILog,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Converte um vetor de caracteres em uma lista que contém as opções para o funcionamento do algoritmo de integração. Serve para facilitar a mudança de opções, dispensando a necessidade de digitá-las por extenso, o que torna o processo de testes dos códigos mais rápidos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
GenList(opt):=
block([solvemethod,mode,modei,ratmethod,logmethod, atanmethod,Ans],
    algebraic:true,
    if opt[1]=N then solvemethod:NoSolve,
    if opt[1]=D then solvemethod:DomSolve,
    if opt[1]=L then solvemethod:LinSolve,
    if opt[1]=Q then solvemethod:QuadSolve,
    if opt[1]=C then solvemethod:CubeSolve,
    if opt[1]=A then solvemethod:solve,
    if opt[2]=C then mode:complex,
    if opt[2]=R then mode:real,
    if opt[3]=R then modei:res,
    if opt[3]=D then modei:den,
    if opt[4]=O then ratmethod:HermO,
    if opt[4]=Q then ratmethod:HermQ,
    if opt[4]=L then ratmethod:HermL,
    if opt[4]=S then ratmethod:HorOstro,
    if opt[5]=B then logmethod:Bern,
    if opt[5]=R then logmethod:RothTra,
    if opt[5]=L then logmethod:LaRiTra,
    if opt[5]=C then logmethod:Czi,
    if opt[6]=C then atanmethod:Classic,
    if opt[6]=R then atanmethod:Rioboo,
    if opt[7]=T then atanhconv:true,
    if opt[7]=F then atanhconv:false,
    Ans:[solvemethod,mode,modei,ratmethod,logmethod, atanmethod,atanhconv],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Integrador de funções racionais. A saída é uma lista em que a primeira entrada contém dados separados de cada etapa do processo de integração e a segunda contém a fórmula da integral.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
IRF(F,x,solvemethod,mode,modei,ratmethod,logmethod, atanmethod,atanhconv):=
block([f,q,r,h,t,Poly,Rat,Log,ILog, compl,inert,R,S,Atan,Atanh,re, expl,impl,RLog,CLog,Int,Ans],
    algebraic:true,
    q:0,
    r:0,
    h:0,
    Poly:0,
    Rat:0,
    Log:0,
    ILog:0,
    re:[],
    compl:[],
    inert:[],
    R:[],
    S:[],
    Atan:0,
    Atanh:0,
    expl:1,
    impl:1,
    RLog:0,
    CLog:0,
    Int:0,
    f:Group(num(F),x)/Group(denom(F),x),
    [q,r]:PDiv(num(f),denom(f),x),
    Poly:integrate(q,x),
    Int:Int+Poly,
    if r=0 then (
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    [Rat,h]:ratmethod(num(r),denom(f),x),
    h:rat(h,x),
    Int:Int+Rat,
    if h=0 then (
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    if logmethod=Bern then (
        [Log,Atan,ILog]:logmethod(num(h),denom(h),x,mode, solvemethod),
        Int:Int+(Log+Atan)+ILog,
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    [R,S]:logmethod(num(h),denom(h),x),
    [re,compl,inert]:Extensions(R,%Z,solvemethod),
    [expl,RLog,Atanh]:RealLog(S,%Z,x,re,modei,atanhconv),
    [expl,CLog,Atan]:ComplLog(S,R,%Z,x,expl,compl,mode,modei ,atanmethod),
    ILog:InertLog(S,%Z,x,h,inert,expl,modei),
    Int:Int+(RLog+CLog+Atan+Atanh)+ILog,
    Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Calcula um polinômio 𝑉 tal que, caso a equação 𝑔 = (𝑢/𝑣)𝑓, com 𝑔 ′ = 𝑓 possua solução no par 𝑢,𝑣, então 𝑉 é um múltiplo de 𝑣.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função DenMult(𝐴,𝐷)
2: descrição: Dado um corpo K de característica 0 e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 mônico e coprimo com 𝐴, retorna 𝑉 ∈ K[𝑥], tal que, para quaisquer coprimos 𝑢,𝑣 ∈ K[𝑥], a equação (A.2) implica que 𝑣 divide 𝑉 .
3:
4: 𝑅 ← res𝑥(𝐷,𝐴 − 𝑧𝐷′ )
5: 𝑑 ← max{𝑖 ∈ N | 𝑖 = 0 ou 𝑅(𝑖) = 0}
6: se 𝑑 = 0 então
7: devolve 1
8: fim se
9: 𝑎0 ← 𝐴, 𝑏0 ← 𝐷
10: para 𝑖 ← 1 até 𝑑 faça
11: 𝐻𝑖 ← mdc(𝑏𝑖−1,𝑎𝑖−1 − 𝑏 ′ 𝑖−1 ), 𝑎𝑖 ← 𝑎𝑖−1 − 𝑏 ′ 𝑖−1 𝐻𝑖 , 𝑏𝑖 ← 𝑏𝑖−1 𝐻𝑖
12: fim para
13: devolve 𝐻1𝐻 2 2 · · · 𝐻 𝑑 𝑑
14: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DenMult(A,D,x):=
block([expr,expr2,R,i,%Z,d,k,V,Hi,a,b,Ans],
    algebraic:true,
    expr:A-%Z*diff(D,x),
    d:0,
    k:1,
    V:1,
    R:SubRes(D,expr,x)[1],
    R:LFactor(R,%Z,false),
    if length(R)=1 then (
        Ans:1,
        algebraic:false,
        return(Ans)
    ),
    R:Solve(R,%Z,DomSolve),
    while (k<=length(R) and lhs(R[k])#0) do (
        i:rhs(R[k]),
        if integerp(i) and d<i then d:i,
        k:k+1
    ),
    if d=0 then (
        Ans:V,
        algebraic:false,
        return(Ans)
    ),
    a:A,
    b:D,
    for i:1 thru d do (
        expr2:a-diff(b,x),
        Hi:GCD(b,a-diff(b,x),x,0,0),
        a:expr2/Hi,
        b:b/Hi,
        V:V*Hi^i 
    ),
    Ans:V,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Almkvist-Zeilberger. Encontra a integral de uma função hiperexponencial, desde que esta integral seja também uma função hiperexponencial.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: função HyperIntegration(𝐴,𝐷)
2: descrição: Dado um corpo K de característica 0 e 𝐴,𝐷 ∈ K[𝑥] com grau(𝐴) < grau(𝐷), 𝐷 mônico e coprimo com 𝐴, retorna 𝑢,𝑣 ∈ K[𝑥], com 𝑣 mônico, satisfazendo (A.2)
3:
4: 𝑉 ←DenMult(𝐴,𝐷)
5: ℎ ← mdc(𝐷𝑉,𝐵𝑉 ′ − 𝐴𝑉 ), 𝑟 ← 𝐷𝑉 ℎ , 𝑠 ← 𝐷𝑉 ′ − 𝐴𝑉 ℎ , 𝑡 ← 𝑟𝑉
6: 𝑚 ← max{grau(𝑟) − 1, grau(𝑠)}
7: 𝛿 ← coeficiente(𝑠,𝑥𝑚)
8: se grau(𝑟) − 1 < grau(𝑠) ou 𝛿 /∈ N então
9: 𝑒 ← grau(𝑡) − 𝑚
10: senão
11: se grau(𝑡) − 𝑚 = 𝛿 então
12: devolve “insolúvel”
13: senão
14: 𝑒 ← max{grau(𝑡) − 𝑚,𝛿}
15: fim se
16: fim se
17: se 𝑒 < 0 então
18: devolve “insolúvel”
19: fim se
20: 𝑈 ← 𝑒−grau( ∑︁ 𝑟) 𝑖=0 𝑢𝑖𝑥 𝑖
21: 𝐻 ← 𝑉 − 𝑟𝑈′ + (𝑠 − 𝑟 ′ ) 
22: (𝑈0, . . . ,𝑈𝑒−grau(𝑟)) ← solucionador(coeficiente(𝐻,𝑥𝑘 ) = 0,0 ≤ 𝑘 ≤ 𝑒 − grau(𝑟))
23: se @(𝑈0, . . . ,𝑈𝑒−grau(𝑟)) | 𝐻 = 0 então
24: devolve “insolúvel”
25: senão
26: devolve 𝑟𝑈 mdc(𝑟𝑈,𝑉 ) , 𝑉 mdc(𝑟𝑈,𝑉 )
27: fim se
28: fim função
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
IHF(f,x):=
block([A,D,h,r,s,t,m,delta,sigma, e,U,V,H,eq,listu,u,sol,G,Ans],
    algebraic:true,
    eq:[],
    sigma:ratsimp(diff(f,x)/f),
    A:num(sigma),
    D:denom(sigma),
    if (polynomialp(A,[x]) and polynomialp(D,[x]))=false then error("not a hyperexponential function."),
    V:DenMult(A,D,x),
    h:GCD(D*V,D*diff(V,x)-A*V,x,0,0),
    r:Group(D*V/h,x),
    s:Group((D*diff(V,x)-A*V)/h,x),
    t:Group(r*V,x),
    m:max(hipow(r,x)-1,hipow(s,x)),
    delta:coeff(s,x,m),
    if hipow(r,x)-1<hipow(s,x) or (integerp(delta) and delta>=0)=false then e:hipow(t,x)-m else if hipow(t,x)-m=delta then (
        Ans:"unsolvable",
        algebraic:false,
        return(Ans)
    ) else e:max(hipow(t,x)-m,delta),
    if e<0 then (
        Ans:"unsolvable",
        algebraic:false,
        return(Ans)
    ),
    U:sum(u[i]*x^(i-1),i,1,e-hipow(r,x)+1),
    H:Group(V-r*diff(U,x)+(s-diff(r,x))*U,x),
    for k:0 thru hipow(H,x) do (
        eq:endcons(coeff(H,x,k)=0,eq)
    ),
    listu:makelist(u[i],i,1,e-hipow(r,x)+1),
    sol:linsolve(eq,listu),
    U:sum(rhs(sol[i])*x^(i-1),i,1,length(sol)),
    if sol=[] then (
        Ans:"unsolvable",
        algebraic=false,
        return(Ans)
    ),
    G:ratsimp(r*U/V),
    Ans:fullratsimp(G*f),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
