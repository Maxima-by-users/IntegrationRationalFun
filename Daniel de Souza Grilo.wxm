/* [wxMaxima batch file version 1] [ DO NOT EDIT BY HAND! ]*/
/* [ Created with wxMaxima version 22.04.0 ] */
/* [wxMaxima: comment start ]
Reescreve, se possÃ­vel, a expressÃ£o ğ´ de modo que se torne um polinÃ´mio na variÃ¡vel ğ‘¥, onde cada potÃªncia de ğ‘¥ ocorre apenas uma vez. AlÃ©m disso, simplifica os coeficientes de cada termo em ğ‘¥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Group(A,x):=
block([a,l,simp,Ans],
    algebraic:true,
    simp:0,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:expandwrt(fullratsimp(A,x),x),
    l:hipow(a,x),
    for i:0 thru l do (
        simp:simp+fullratsimp(coeff(a,x,i))*x^i
    ),
    Ans:simp,
    algebraic:false,
    return(ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O coeficiente lÃ­der do polinÃ´mio ğ´ na variÃ¡vel ğ‘¥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LC(A,x):=
block([a,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:Group(A,x),
    a:coeff(a,x,hipow(a,x)),
    Ans:a,
    algebraic:false,return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O polinÃ´mio mÃ´nico de ğ´ na varÃ¡vel ğ‘¥. Obtido pela divisÃ£o de ğ´ por seu termo lÃ­der em ğ‘¥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Mon(A,x):=
block([a,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    a:Group(A/LC(A,x),x),
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna polinÃ´mios ğ´ e ğµ tais que ğ‘ƒ(ğ‘¢ + ğ¼ğ‘£) = ğ´(ğ‘¢,ğ‘£) + ğ¼ğµ(ğ‘¢,ğ‘£), com os coeficientes de ğ´ e ğµ pertencentes ao mesmo domÃ­nio dos coeficientes de ğ‘ƒ.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Parts(P,z):=
block([u,v,p,Ans],
    algebraic:true,
    p:subst(u+%i*v,z,P),
    Ans:[realpart(p),imagpart(p)],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Gera polinÃ´mios inteiros aleatÃ³rios. ğ‘‘ğ‘’ğ‘” Ã© o grau desejado, ğ‘™ğ‘–ğ‘š Ã© o limitante para o valor absoluto dos coeficientes e ğ‘‘ğ‘œğ‘š Ã© o domÃ­nio: naturais ou inteiros.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RPoly(x,deg,lim,dom):=
block([j,s,Poly,Ans],
    algebraic:true,
    Poly:0,
    for j:0 thru deg do (
        s:1,
        if random(2)=0 and dom="integers" then s:-1,
        Poly:Poly+s*random(lim+1)*x^j
    ),
    if hipow(Poly,x)<deg then Poly:Poly+x^deg,
    if Poly=0 then (
        Ans:1,
        algebraic:false,return(Ans)
    ),
    Ans:Poly,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna o quociente e o resto da divisÃ£o de ğ´ por ğµ visto como polinÃ´mios em ğ‘¥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o PolyDivide(ğ´,ğµ)
2: descriÃ§Ã£o: Dado um corpo K e ğ´,ğµ âˆˆ K[ğ‘¥] com ğµ Ì¸= 0, retorna ğ‘„,ğ‘… âˆˆ K[ğ‘¥] tais que ğ´ = ğµğ‘„ + ğ‘…, com ğ‘… = 0 ou grau(ğ‘…) < grau(ğµ).
3: ğ‘„ â† 0
4: ğ‘… â† ğ´
5: enquanto ğ‘… Ì¸= 0 e ğ›¿ â† grau(ğ‘…) âˆ’ grau(ğµ) â‰¥ 0 faÃ§a
6: ğ‘‡ â† cl(ğ‘…) cl(ğµ) ğ‘¥ ğ›¿
7: ğ‘„ â† ğ‘„ + ğ‘‡
8: ğ‘… â† ğ‘… âˆ’ ğµğ‘‡
9: fim enquanto
10: devolve (ğ‘„,ğ‘…)
11: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PDiv(A,B,x):=
block([b,q,r,t,delta,lcB,degB,Ans],
    algebraic:true,
    q:0,
    r:Group(A,x),
    b:Group(B,x),
    degB:hipow(b,x),
    delta:hipow(r,x)-degB,
    lcB:LC(b,x),
    while r#0 and delta>=0 do (
        t:fullratsimp(LC(r,x)/lcB)*x^delta,
        q:q+t,
        r:r-b*t,
        q:Group(q,x),
        r:Group(r,x),
        delta:hipow(r,x)-degB
    ),
    Ans:[q,r],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Retorna o pseudoquociente e o pseudoresto da divisÃ£o de ğ´ por ğµ visto como polinÃ´mios em ğ‘¥.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o PolyPseudoDivide(ğ´,ğµ)
2: descriÃ§Ã£o: Dado um domÃ­nio de integridade ğ· e ğ´,ğµ âˆˆ ğ·[ğ‘¥] com ğµ Ì¸= 0, retorna pquo(ğ´,ğµ) e prem(ğ´,ğµ).
3: ğ‘ â† cl(ğµ)
4: ğ‘ â† grau(ğ‘…) âˆ’ grau(ğµ) + 1
5: ğ‘„ â† 0
6: ğ‘… â† ğ´
7: enquanto ğ‘… Ì¸= 0 e ğ›¿ â† grau(ğ‘…) âˆ’ grau(ğµ) â‰¥ 0 faÃ§a
8: ğ‘‡ â† cl(ğ‘…)ğ‘¥ ğ›¿
9: ğ‘ â† ğ‘ âˆ’ 1
10: ğ‘„ â† ğ‘ğ‘„ + ğ‘‡
11: ğ‘… â† ğ‘ğ‘… âˆ’ ğµğ‘‡
12: fim enquanto
13: devolve (ğ‘ ğ‘ ğ‘„,ğ‘ğ‘ ğ‘…)
14: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PPsDiv(A,B,x):=
block([b,q,r,t,delta,lcB,degB,N],
    algebraic:true,
    q:0,
    r:Group(A,x),
    b:Group(B,x),
    degB:hipow(b,x),
    delta:max(hipow(r,x)-degB,-1),
    lcB:LC(b,x),
    N:delta+1,
    while r#0 and delta>=0 do (
        t:LC(r,x)*x^delta,
        N:N-1,
        q:lcB*q+t,
        r:lcB*r-b*t,
        q:Group(q,x),
        r:Group(r,x),
        delta:hipow(r,x)-degB
    ),
    q:Group(lcB^N*q,x),
    r:Group(lcB^N*r,x),
    Ans:[q,r],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
CÃ¡lculo de mdc de polinÃ´mios utilizando a SRP primitiva. HÃ¡ a possibilidade de se realizar os cÃ¡lculos mÃ³dulo ğ‘ƒ(ğ‘§). Isto se mostrarÃ¡ Ãºtil especialmente no algoritmo de Rothstein-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o Euclidean(ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘ âˆˆ ğ·, retorna mdc(ğ‘,ğ‘).
3: enquanto ğ‘ Ì¸= 0 faÃ§a
4: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘) â— ğ‘ = ğ‘ğ‘ + ğ‘Ÿ
5: ğ‘ â† ğ‘
6: ğ‘ â† ğ‘Ÿ
7: fim enquanto
8: devolve ğ‘
9: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
GCD(A,B,x,P,z):=
block([a,b,q,r,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    if P#0 then (
        a:PPsDiv(a,P,z)[2],
        b:PPsDiv(b,P,z)[2]
    ),
    while b#0 do (
        [q,r]:PPsDiv(a,b,x),
        if P#0 then (
            r:PPsDiv(num(r),P,z)[2],
            if r#0 then r:content(Group(r,x),x)[2]
        ),
        a:b,
        b:content(r,x)[2],
        if r=0 then b:0
    ),
    a:content(a,x)[2],
    if LC(a,x)<0 then (
        a:Group((-a),x)
    ),
    Ans:a,
    algebraic:false,return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides estendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o ExtendedEuclidean(ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘ âˆˆ ğ·, retorna ğ‘ ,ğ‘¡,ğ‘‘ âˆˆ ğ· tais que ğ‘‘ = mdc(ğ‘,ğ‘) e ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘‘.
3: ğ‘1 â† 1
4: ğ‘2 â† 0
5: ğ‘1 â† 0
6: ğ‘2 â† 1
7: enquanto ğ‘ Ì¸= 0 faÃ§a
8: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘) â— ğ‘ = ğ‘ğ‘ + ğ‘Ÿ
9: ğ‘ â† ğ‘
10: ğ‘ â† ğ‘Ÿ
11: ğ‘Ÿ1 â† ğ‘1 âˆ’ ğ‘ğ‘1
12: ğ‘Ÿ2 â† ğ‘2 âˆ’ ğ‘ğ‘2
13: ğ‘1 â† ğ‘1
14: ğ‘2 â† ğ‘2
15: ğ‘1 â† ğ‘Ÿ1
16: ğ‘2 â† ğ‘Ÿ2
17: fim enquanto
18: devolve (ğ‘1,ğ‘2,ğ‘)
19: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ExGCD(A,B,x):=
block([a,b,q,r,a1,a2,b1,b2,r1,r2,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    a1:1,
    a2:0,
    b1:0,
    b2:1,
    while b#0 do (
        [q,r]:PDiv(a,b,x),
        a:b,
        b:r,
        r1:a1-q*b1,
        r2:a2-q*b2,
        a1:b1,
        a2:b2,
        b1:r1,
        b2:r2
    ),
    Ans:expand([a1,a2,a]),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides semiestendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HalfExtendedEuclidean(ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘ âˆˆ ğ·, retorna ğ‘ ,ğ‘‘ âˆˆ ğ· tais que ğ‘‘ = mdc(ğ‘,ğ‘) e ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘‘ para algum ğ‘¡ âˆˆ ğ·.
3: ğ‘1 â† 1
4: ğ‘1 â† 0
5: enquanto ğ‘ Ì¸= 0 faÃ§a
6: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘) â— ğ‘ = ğ‘ğ‘ + ğ‘Ÿ
7: ğ‘ â† ğ‘
8: ğ‘ â† ğ‘Ÿ
9: ğ‘Ÿ1 â† ğ‘1 âˆ’ ğ‘ğ‘1
10: ğ‘1 â† ğ‘1
11: ğ‘1 â† ğ‘Ÿ1
12: fim enquanto
13: devolve (ğ‘1,ğ‘)
14: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HExGCD(A,B,x):=
block([a,b,q,r,a1,b1,r1,Ans],
    algebraic:true,
    a:A,
    b:B,
    a1:1,
    b1:0,
    while b#0 do (
        [q,r]:PDiv(a,b,x),
        a:b,
        b:r,
        r1:a1-q*b1,
        a1:b1,
        b1:r1
    ),
    Ans:[a1,a],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Euclides estendido calculado a partir do semiestendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o ExtendedEuclidean(ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘ âˆˆ ğ·, retorna ğ‘ ,ğ‘¡,ğ‘‘ âˆˆ ğ· tais que ğ‘‘ = mdc(ğ‘,ğ‘) e ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘‘.
3: (ğ‘ ,ğ‘‘) â† HalfExtendedEuclidean(ğ‘,ğ‘) â— ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘‘ para algum ğ‘¡
4: (ğ‘¡,ğ‘Ÿ) â† EuclideanDivision(ğ‘‘ âˆ’ ğ‘ ğ‘,ğ‘) â— ğ‘Ÿ deve ser 0
5: devolve (ğ‘ ,ğ‘¡,ğ‘‘)
6: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HFExGCD(A,B,x):=
block([a,b,s,r,g,t,Ans],
    algebraic:true,
    a:A,
    b:B,
    [s,g]:HExGCD(a,b,x),
    [t,r]:PDiv(g-s*A,B,x),
    Ans:[s,t,g],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o diofantina do algoritmo de Euclides estendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o ExtendedEuclidean(ğ‘,ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘,ğ‘ âˆˆ ğ· e ğ‘ mÃºltiplo de mdc(ğ‘,ğ‘), retorna ğ‘ ,ğ‘¡ âˆˆ ğ· tais que ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘, com ğ‘  = 0 ou ğœˆ(ğ‘ ) < ğœˆ(ğ‘).
3: (ğ‘ ,ğ‘¡,ğ‘‘) â† ExtendedEuclidean(ğ‘,ğ‘) â— ğ‘‘ = ğ‘ ğ‘ + ğ‘¡ğ‘
4: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘‘) â— ğ‘ = ğ‘‘ğ‘ + ğ‘Ÿ
5: se ğ‘Ÿ Ì¸= 0 entÃ£o
6: erro: â€œğ‘ nÃ£o Ã© mÃºltiplo de mdc(ğ‘,ğ‘)â€
7: fim se
8: ğ‘  â† ğ‘ğ‘ 
9: ğ‘¡ â† ğ‘ğ‘¡
10: se ğ‘  Ì¸= 0 e ğœˆ(ğ‘ ) â‰¥ ğœˆ(ğ‘) entÃ£o
11: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘ ,ğ‘) â— ğ‘  = ğ‘ğ‘ + ğ‘Ÿ
12: fim se
13: ğ‘  â† ğ‘Ÿ
14: ğ‘¡ â† ğ‘¡ + ğ‘ğ‘
15: devolve ğ‘ ,ğ‘¡
16: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioExGCD(A,B,C,x):=
block([s,t,g,q,r,Ans],
    algebraic:true,
    [s,t,g]:HFExGCD(A,B,x),
    [s,t,g]:expand([s,t,g]),
    [q,r]:PDiv(C,g,x),
    if r#0 then (
        algebraic:false,
        error("c is not in the ideal generated by a and b")
    ),
    s:q*s,
    t:q*t,
    [s,t]:expand([s,t]),
    if s#0 and hipow(s,x)>=hipow(B,x) then (
        [q,r]:PDiv(s,B,x),
        s:r,
        t:t+q*A
    ),
    Ans:[s,t],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o diofantina do algoritmo de Euclides semiestendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HalfExtendedEuclidean(ğ‘,ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘,ğ‘ âˆˆ ğ· e ğ‘ mÃºltiplo de mdc(ğ‘,ğ‘), retorna ğ‘  âˆˆ ğ· tal que ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘ para algum ğ‘¡ âˆˆ ğ·, com ğ‘  = 0 ou ğœˆ(ğ‘ ) < ğœˆ(ğ‘).
3: (ğ‘ ,ğ‘‘) â† HalfExtendedEuclidean(ğ‘,ğ‘) â— ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘‘ para algum ğ‘¡ âˆˆ ğ·
4: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘‘) â— ğ‘ = ğ‘‘ğ‘ + ğ‘Ÿ
5: se ğ‘Ÿ Ì¸= 0 entÃ£o
6: erro: ğ‘ nÃ£o Ã© mÃºltiplo de mdc(ğ‘,ğ‘)
7: fim se
8: ğ‘  â† ğ‘ğ‘ 
9: se ğ‘  Ì¸= 0 e ğœˆ(ğ‘ ) â‰¥ ğœˆ(ğ‘) entÃ£o
10: (ğ‘,ğ‘Ÿ) â† EuclideanDivision(ğ‘ ,ğ‘) â— ğ‘  = ğ‘ğ‘ + ğ‘Ÿ
11: fim se
12: ğ‘  â† ğ‘Ÿ
13: devolve ğ‘ 
14: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioHExGCD(A,B,C,x):=
block([s,g,q,r,Ans],
    algebraic:true,
    [s,g]:HExGCD(A,B,x),
    [s,g]:expand([s,g]),
    [q,r]:PDiv(C,g,x),
    if r#0 then (
        algebraic:false,
        error("c is not in the ideal generated by a and b")
    ),
    s:q*s,
    s:expand(s),
    if s#0 and hipow(s,x)>=hipow(B,x) then (
        [q,r]:PDiv(s,B,x),
        s:r
    ),
    Ans:s,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o diofantina do algoritmo de Euclides calculado a partir do semiestendido. AplicÃ¡vel a domÃ­nios euclidianos de polinÃ´mios.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o ExtendedEuclidean(ğ‘,ğ‘)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘,ğ‘ âˆˆ ğ·, com ğ‘ mÃºltiplo de mdc(ğ‘,ğ‘) retorna ğ‘ ,ğ‘¡ âˆˆ ğ· tais que ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘, com ğ‘  = 0 ou ğœˆ(ğ‘ ) < ğœˆ(ğ‘).
3: ğ‘  â† HalfExtendedEuclidean(ğ‘,ğ‘,ğ‘) â— ğ‘ ğ‘ + ğ‘¡ğ‘ = ğ‘ para algum ğ‘¡
4: (ğ‘¡,ğ‘Ÿ) â† EuclideanDivision(ğ‘ âˆ’ ğ‘ ğ‘,ğ‘) â— ğ‘Ÿ deve ser 0
5: devolve (ğ‘ ,ğ‘¡)
6: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DioHFExGCD(A,B,C,x):=
block([s,r,t,Ans],
    algebraic:true,
    s:DioHExGCD(A,B,C,x),
    [t,r]:PDiv(C-s*A,B,x),
    Ans:[s,t],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo das subresultantes.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o SubResultant(ğ´,ğµ)
2: descriÃ§Ã£o: Dado um domÃ­nio de integridade ğ· e ğ´,ğµ âˆˆ ğ·[ğ‘¥] com ğµ = 0 Ì¸ e grau(ğ´) â‰¥ grau(ğµ), retorna res(ğ´,ğµ) e a SRP subresultante (ğ‘…0,ğ‘…1, . . . ,ğ‘…ğ‘˜,0) de ğ´ e ğµ.
3: ğ‘…0 â† ğ´
4: ğ‘…1 â† ğµ
5: ğ‘– â† 1
6: ğ›¾1 â† âˆ’1
7: ğ›¿1 â† grau(ğ´) âˆ’ grau(ğµ)
8: ğ›½1 â† (âˆ’1)ğ›¿1+1
9: enquanto ğ‘…ğ‘– Ì¸= 0 faÃ§a
10: ğ‘Ÿğ‘– â† cl(ğ‘…ğ‘–)
11: (ğ‘„,ğ‘…) â† PolyPseudoDivide(ğ‘…ğ‘–âˆ’1,ğ‘…ğ‘–)
12: ğ‘…ğ‘–+1 â† ğ‘…/ğ›½ğ‘– â— esta divisÃ£o Ã© sempre exata
13: ğ‘– â† ğ‘– + 1
14: ğ›¾ğ‘–(âˆ’ğ‘Ÿğ‘–âˆ’1) ğ›¿ğ‘–âˆ’1 ğ›¾ 1âˆ’ğ›¿ğ‘–âˆ’1 ğ‘–âˆ’1
15: ğ›¿ğ‘– â† grau(ğ‘…ğ‘–âˆ’1) âˆ’ grau(ğ‘…ğ‘–)
16: ğ›½ğ‘– â† âˆ’ğ‘Ÿğ‘–âˆ’1ğ›¾ ğ›¿ğ‘– ğ‘–
17: fim enquanto
18: ğ‘˜ â† ğ‘– âˆ’ 1
19: se grau(ğ‘…ğ‘˜) > 0 entÃ£o
20: devolve (0,(ğ‘…0,ğ‘…1, Â· Â· Â· ,ğ‘…ğ‘˜,0))
21: fim se
22: se grau(ğ‘…ğ‘˜âˆ’1) = 1 entÃ£o
23: devolve (ğ‘…ğ‘˜,(ğ‘…0,ğ‘…1, Â· Â· Â· ,ğ‘…ğ‘˜,0))
24: fim se
25: ğ‘  â† 1 â— ğ‘  serÃ¡ (âˆ’1)ğœğ‘˜
26: ğ‘ â† 1 â— ğ‘ ğ‘…grau(ğ‘…ğ‘˜âˆ’1)âˆ’1 ğ‘˜ ğ‘ serÃ¡ ğœğ‘˜
27: para ğ‘— â† 1 atÃ© ğ‘˜ âˆ’ 1 faÃ§a â— computa ğœğ‘˜ğ‘…ğ‘˜
28: se grau(ğ‘…ğ‘—âˆ’1) for Ã­mpar e grau(ğ‘…ğ‘— ) for Ã­mpar entÃ£o
29: ğ‘  â† âˆ’ğ‘ 
30: fim se
31: ğ‘ â† ğ‘(ğ›½ğ‘—/ğ‘Ÿ1+ğ›¿ğ‘— ğ‘— ) grau(ğ‘…ğ‘— ) ğ‘Ÿ grau(ğ‘…ğ‘—âˆ’1)âˆ’grau(ğ‘…ğ‘—+1) ğ‘— â— divisÃ£o exata
32: fim para
33: devolve (ğ‘ ğ‘ğ‘…grau(ğ‘…ğ‘˜âˆ’1) ğ‘˜ ,(ğ‘…0,ğ‘…1 . . . ,ğ‘…ğ‘˜,0))
34: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SubRes(A,B,x):=
block([R,i,gamma,delta,Res, beta,pq,pr,r,k,s,c,j,Ans],
    algebraic:true,
    R:[],
    gamma:[],
    delta:[],
    beta:[],
    r:[],
    push(Group(B,x),R),
    push(Group(A,x),R),
    i:2,
    push(-1,gamma),
    push(hipow(R[1],x)-hipow(R[2],x),delta),
    push((-1)^(delta[1]+1),beta),
    while R[i]#0 do (
        r:endcons(LC(R[i],x),r),
        [pq,pr]:PPsDiv(R[i-1],R[i],x),
        R:endcons(Group(pr/beta[i-1],x),R),
        gamma:endcons((-r[i-1])^delta[i-1]*gamma[i-1]^(1- delta[i-1]),gamma),
        delta:endcons(hipow(R[i],x)-hipow(R[i+1],x),delta),
        beta:endcons(-r[i-1]*gamma[i]^delta[i],beta),
        i:i+1
    ),
    k:i-1,
    if hipow(R[k],x)>0 then (
        Ans:[0,rest(R,-1)],
        algebraic:false,
        return(Ans)
    ),
    if hipow(R[k-1],x)=1 then (
        Ans:[R[k],rest(R,-1)],
        algebraic:false,
        return(Ans)
    ),
    s:1,
    c:1,
    for j:1 thru k-2 do (
        if mod(hipow(R[j],x),2)=1 and mod(hipow(R[j+1],x),2)=1 then s:-s,
        c:c*(beta[j]/r[j]^(1+delta[j]))^hipow(R[j+1],x) *r[j]^(hipow(R[j],x)-hipow(R[j+2],x))
    ),
    Res:s*c*R[k]^(hipow(R[k-1],x)),
    Ans:[Res,rest(R,-1)],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Normaliza o mdc entre dois polinÃ´mios para que seu coeficiente lÃ­der seja congruente a 1 mod ğ‘ƒ(ğ‘§).
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Normalize(A,x,P,z):=
block([a,mult,Ans],
    algebraic:true,
    mult:HExGCD(LC(A,x),P,z)[1],
    a:mult*A,
    a:PDiv(a,P,z)[2],
    a:content(Group(a,x))[2],
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O mesmo que a funÃ§Ã£o factor do Maxima, porÃ©m retorna uma lista com os fatores da fatoraÃ§Ã£o prima do polinÃ´mio ğ‘„, ao invÃ©s de um produto. ğ‘’ğ‘¥ğ‘ğ‘ deve ter valor ğ‘¡ğ‘Ÿğ‘¢ğ‘’ caso se deseje expandir os fatores.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LFactor(Q,x,expa):=
block([fac,l,i,c,q,listfac,Ans],
    algebraic:true,
    listfac:[],
    if hipow(Q,x)=0 then (
        Ans:[Q],
        algebraic:false,
        return(Ans)
    ),
    [c,q]:content(Q,x),
    q:Group(q,x),
    fac:factor(q),
    fac:2*fac^3,
    if op(fac)="-" then (
        c:-c,
        fac:-fac
    ),
    l:length(fac),
    push(c,listfac),
    for i:2 thru l do (
        listfac:endcons(second(fac)^(1/3),listfac),
        fac:fac/second(fac),
        if expa then listfac[i]:Group(listfac[i],x)
    ),
    Ans:listfac,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
FatoraÃ§Ã£o livre de quadrados pelo algoritmo de Yun.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o SquareFree(ğ´)
2: descriÃ§Ã£o: Dado um domÃ­nio de fatoraÃ§Ã£o Ãºnica ğ· com caracterÃ­stica 0 e ğ´ âˆˆ ğ·[ğ‘¥], retorna ğ´1, . . . ,ğ´ğ‘š âˆˆ ğ·[ğ‘¥] tais que ğ´ = âˆï¸ğ‘š ğ‘˜=1 ğ´ ğ‘˜ ğ‘˜ Ã© uma fatoraÃ§Ã£o livre de quadrados de ğ´.
3: ğ‘ â† cont(ğ´)
4: ğ‘† â† ğ´/ğ‘ â— ğ‘† = pp(ğ´)
5: ğ‘† â€² â† ğ‘‘ğ‘†/ğ‘‘ğ‘¥
6: ğ‘† âˆ’ â† mdc(ğ‘†,ğ‘†â€² )
7: ğ‘† * â† ğ‘†/ğ‘†âˆ’
8: ğ‘Œ â† ğ‘† â€² /ğ‘†âˆ’
9: ğ‘˜ â† 1
10: enquanto (ğ‘ â† ğ‘Œ âˆ’ ğ‘‘ğ‘†* /ğ‘‘ğ‘¥) Ì¸= 0 faÃ§a â— ğ‘†* = ğ´ âˆ’ğ‘˜âˆ’1 * , ğ‘Œ â† ğ‘Œğ‘˜
11: ğ´ğ‘˜ â† mdc(ğ‘† * ,ğ‘) â— (2.12)
12: ğ‘† * â† ğ‘† * /ğ´ğ‘˜ â— ğ‘†* = ğ´ âˆ’ğ‘˜ *
13: ğ‘Œ â† ğ‘/ğ´ğ‘˜ â— ğ‘Œ = ğ‘Œğ‘˜+1
14: ğ‘˜ â† ğ‘˜ + 1
15: fim enquanto
16: ğ´ğ‘˜ â† ğ‘† *
17: devolve (ğ‘ğ´1, . . . ,ğ´ğ‘˜)
18: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SQFR(A,x):=
block([S,Sd,Sf,Y,fac,Z,k,c,dS,Ans],
    algebraic:true,
    fac:[],
    [c,S]:content(A,x),
    dS:Group(diff(S,x),x),
    Sd:GCD(S,dS,x,0,0),
    Sf:Group(S/Sd,x),
    Y:Group(dS/Sd,x),
    Z:Group(Y-diff(Sf,x),x),
    k:1,
    while Z#0 do (
        fac:endcons(GCD(Sf,Z,x,0,0),fac),
        Sf:Group(Sf/fac[k],x),
        Y:Group(Z/fac[k],x),
        Z:Group(Y-diff(Sf,x),x),
        k:k+1
    ),
    fac:endcons(Sf,fac),
    fac[1]:Group(c*fac[1],x),
    Ans:fac,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
DecomposiÃ§Ã£o em fraÃ§Ãµes parciais simples.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o PartialFraction(ğ‘,ğ‘‘1, . . . ,ğ‘‘ğ‘›)
2: descriÃ§Ã£o: Dado um domÃ­nio euclidiano ğ· e ğ‘,ğ‘‘1, . . . ,ğ‘‘ğ‘› âˆˆ ğ· âˆ– {0} com mdc(ğ‘‘ğ‘– ,ğ‘‘ğ‘— ) = 1 para ğ‘– Ì¸= ğ‘—, retorna ğ‘0,ğ‘1, . . . ,ğ‘ğ‘› âˆˆ ğ· tais que ğ‘ ğ‘‘1 Â· Â· Â· ğ‘‘ğ‘› = ğ‘0 + âˆ‘ï¸ğ‘› ğ‘–=1 ğ‘ğ‘– ğ‘‘ğ‘– com ğ‘ğ‘– = 0 ou ğœˆ(ğ‘ğ‘–) < ğœˆ(ğ‘‘ğ‘–) para ğ‘– â‰¥ 1.
3: (ğ‘0,ğ‘Ÿ) â† EuclideanDivision(ğ‘,ğ‘‘1, . . . ,ğ‘‘ğ‘›) â— ğ‘ = (ğ‘‘1 Â· Â· Â· ğ‘‘ğ‘›)ğ‘0 + ğ‘Ÿ
4: se ğ‘› = 1 entÃ£o
5: devolve (ğ‘0,ğ‘Ÿ)
6: fim se
7: (ğ‘1,ğ‘¡) â† ExtendedEuclidean(ğ‘‘2 Â· Â· Â· ğ‘‘ğ‘›,ğ‘‘1,ğ‘Ÿ) â— ğœˆ(ğ‘1) < ğœˆ(ğ‘‘1)
8: (ğ‘0,ğ‘2, . . . ,ğ‘ğ‘›) â† PartialFraction(ğ‘¡,ğ‘‘2, . . . ,ğ‘‘ğ‘›)
9: devolve (ğ‘0 + ğ‘0,ğ‘1,ğ‘2, . . . ,ğ‘ğ‘›)
10: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
PFrac(A,Fac,x):=
block([fac,len,Den,a,a0,r,aux,t,Ans],
    algebraic:true,
    a:makelist(0,1),
    fac:copylist(Fac),
    len:length(fac),
    Den:product(fac[i],i,1,len),
    [a0,r]:PDiv(A,Den,x),
    if len=1 then (
        Ans:[a0,r],
        algebraic:false,
        return(Ans)
    ),
    Den:Den/fac[1],
    [a[1],t]:DioHFExGCD(Den,fac[1],r,x),
    pop(fac),
    aux:PFrac(t,fac,x),
    push(aux[1],a),
    pop(aux),
    a:append(a,aux),
    Ans:a,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o original da reduÃ§Ã£o de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HermiteReduce(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K e ğ´,ğ· âˆˆ K[ğ‘¥] com ğ· nÃ£o nulo e coprimo com ğ´, retorna ğ‘”,â„ âˆˆ K(ğ‘¥) tais que ğ´/ğ· = ğ‘” â€² + â„ com â„ possuindo um denominador livre de quadrados.
3: (ğ·1, . . . ,ğ·ğ‘š) â† SquareFree(ğ·)
4: (ğ‘ƒ,ğ´1,ğ´2, . . . ,ğ´ğ‘›) â† PartialFraction(ğ´,ğ·1,ğ·2 2 , . . . ,ğ·ğ‘› ğ‘› )
5: ğ‘” â† 0
6: â„ â† ğ‘ƒ + ğ´1/ğ·1
7: para ğ‘˜ â† 2 atÃ© ğ‘› tal que grau(ğ·ğ‘˜) > 0 faÃ§a
8: ğ‘‰ â† ğ·ğ‘˜
9: para ğ‘— â† ğ‘˜ âˆ’ 1 atÃ© 1 passo âˆ’1 faÃ§a
10: (ğµ,ğ¶) â† ExtendedEuclidean(ğ‘‰ â€² ,ğ‘‰, âˆ’ ğ´ğ‘˜/ğ‘—)
11: ğ‘” â† ğ‘” + ğµ/ğ‘‰ ğ‘—
12: ğ´ğ‘˜ â† âˆ’ğ‘—ğ¶ âˆ’ ğµ â€²
13: fim para 
14: â„ â† â„ + ğ´ğ‘˜/ğ‘‰
15: fim para
16: devolve (ğ‘”,â„)
17: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermO(A,D,x):=
block([SF,SFExp,PF,g,h,k,V,dV,B,C,j,n,Ans],
    algebraic:true,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    SF:SQFR(D,x),
    n:length(SF),
    SFExp:makelist(SF[i]^i,i,1,n),
    PF:PFrac(A,SFExp,x),
    g:0,
    h:PF[1]+fullratsimp(PF[2])/SF[1],
    for k:2 thru n do (
        if hipow(SF[k],x)>0 then (
            V:SF[k],
            dV:diff(V,x),
            for j:k-1 thru 1 step -1 do (
                [B,C]:DioHFExGCD(dV,V,-expand (fullratsimp(PF[k+1]/j)),x),
                g:g+fullratsimp(B)/V^j,
                PF[k+1]:-j*C-diff(B,x)
            ),
            h:h+fullratsimp(PF[k+1])/V
        )
    ),
    Ans:[g,h],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o quadrÃ¡tica da reduÃ§Ã£o de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HermiteReduce(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K e ğ´,ğ· âˆˆ K[ğ‘¥] com ğ· nÃ£o nulo e coprimo com ğ´, retorna ğ‘”,â„ âˆˆ K(ğ‘¥) tais que ğ´/ğ· = ğ‘” â€² + â„ com â„ possuindo um denominador livre de quadrados.
3: ğ‘” â† 0
4: (ğ·1, . . . ,ğ·ğ‘š) â† SquareFree(ğ·)
5: para ğ‘– â† 2 atÃ© ğ‘š tal que grau(ğ·ğ‘–) > 0 faÃ§a
6: ğ‘‰ â† ğ·ğ‘–
7: ğ‘ˆ â† ğ·/ğ‘‰ ğ‘–
8: para ğ‘— â† ğ‘– âˆ’ 1 atÃ© 1 passo âˆ’1 faÃ§a
9: (ğµ,ğ¶) â† ExtendedEuclidean(ğ‘ˆğ‘‰ â€² ,ğ‘‰, âˆ’ ğ´/ğ‘—)
10: ğ‘” â† ğ‘” + ğµ/ğ‘‰ ğ‘—
11: ğ´ â† âˆ’ğ‘—ğ¶ âˆ’ ğ‘ˆğµâ€²
12: fim para
13: ğ· â† ğ‘ˆğ‘‰
14: fim para
15: devolve (ğ‘”,ğ´/ğ·)
16: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermQ(A,D,x):=
block([SF,SFExp,a,d,g,h,k,V,dV,U,B,C,j,n,Ans],
    algebraic:true,
    a:A,
    d:D,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    g:0,
    SF:SQFR(D,x),
    n:length(SF),
    for k:2 thru n do (
        if hipow(SF[k],x)>0 then (
            V:SF[k],
            dV:expand(diff(V,x)),
            U:expand(fullratsimp(d/V^k)),
            for j:k-1 thru 1 step -1 do (
                [B,C]:DioHFExGCD(expand(U*dV), V,-expand(fullratsimp(a/j)),x),
                g:g+fullratsimp(B)/V^j,
                a:expand(fullratsimp(-j*C-U*diff(B,x)))
            ),
            d:U*V)
    ),
    Ans:[g,fullratsimp(a)/d],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
VersÃ£o linear da reduÃ§Ã£o de Hermite.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HermiteReduce(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K e ğ´,ğ· âˆˆ K[ğ‘¥] com ğ· nÃ£o nulo e coprimo com ğ´, retorna ğ‘”,â„ âˆˆ K(ğ‘¥) tais que ğ´/ğ· = ğ‘” â€² + â„ com â„ possuindo um denominador livre de quadrados.
3: ğ‘” â† 0
4: ğ· âˆ’ â† mdc(ğ·,ğ·â€² )
5: ğ· * â† ğ·/ğ·âˆ’
6: enquanto grau(ğ· âˆ’) > 0 faÃ§a
7: ğ· âˆ’2 â† mdc(ğ· âˆ’,ğ·âˆ’â€² )
8: ğ· âˆ’* â† ğ· âˆ’/ğ·âˆ’2
9: (ğµ,ğ¶) â† ExtendedEuclidean(âˆ’ğ· *ğ· âˆ’â€² /ğ·âˆ’,ğ·âˆ’* ,ğ´)
10: ğ´ â† ğ¶ âˆ’ ğµ â€²ğ· * /ğ·âˆ’* â— novo numerador
11: ğ‘” â† ğ‘” + ğµ/ğ·âˆ’
12: ğ· âˆ’ â† ğ· âˆ’2 â— ğ· âˆ’ = ğ· âˆ’2
13: fim enquanto
14: devolve (ğ‘”,ğ´/ğ·* )
15: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HermL(A,D,x):=
block([a,Dd,Dd2,Df,Ddf,degDd,dDd,g,B,C,Ans],
    algebraic:true,
    a:A,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    g:0,
    Dd:GCD(D,diff(D,x),x,0,0),
    Df:Group(D/Dd,x),
    degDd:hipow(Dd,x),
    while degDd>0 do (
        dDd:Group(diff(Dd,x),x),
        Dd2:GCD(Dd,dDd,x,0,0),
        Ddf:Group(Dd/Dd2,x),
        [B,C]:DioHFExGCD(Group(-Df*dDd /Dd,x),Ddf,a,x),
        a:Group(C-diff(B,x)*Df/Ddf,x),
        g:g+fullratsimp(B)/Dd,
        Dd:Dd2,
        degDd:hipow(Dd,x)
    ),
    Ans:[g,fullratsimp(a)/Df],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
MÃ©todo de Horowitz-Ostrogradsky.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HorowitzOstrogradsky(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· nÃ£o nulo e coprimo com ğ´, retorna ğ‘”,â„ âˆˆ K(ğ‘¥) tais que ğ´/ğ· = ğ‘” â€² + â„ com â„ possuindo um denominador livre de quadrados.
3: ğ· âˆ’ â† mdc(ğ·,ğ·â€² )
4: ğ· * â† ğ·/ğ·âˆ’
5: ğ‘› â† grau(ğ· âˆ’) âˆ’ 1
6: ğ‘š â† grau(ğ· * ) âˆ’ 1
7: ğ‘‘ â† grau(ğ·)
8: ğµ â† âˆ‘ï¸ğ‘› ğ‘–=0 ğ‘ğ‘–ğ‘¥ ğ‘–
9: ğ¶ â† âˆ‘ï¸ğ‘š ğ‘—=0 ğ‘ğ‘—ğ‘¥ ğ‘—
10: ğ» â† ğ´ âˆ’ ğµ â€²ğ· * + ğµğ·*ğ· âˆ’â€² /ğ·âˆ’ âˆ’ ğ¶ğ·âˆ’ â— divisÃ£o exata
11: (ğ‘0, . . . ,ğ‘ğ‘›,ğ‘0, . . . ,ğ‘ğ‘›) â† solucionador(coeficiente(ğ»,ğ‘¥ğ‘˜ ) = 0,0 â‰¤ ğ‘˜ â‰¤ ğ‘‘)
12: devolve âˆ‘ï¸ğ‘› ğ‘–=0 ğ‘ğ‘–ğ‘¥ ğ‘– /ğ·âˆ’, âˆ‘ï¸ğ‘š ğ‘–=0 ğ‘ğ‘—ğ‘¥ ğ‘— /ğ·*
13: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
HorOstro(A,D,x):=
block([a,Dd,Df,dDd,n,m,d,C,B,dB,H,j,b,c,k,eq,listb, listc,listvar,sol,Rac,Log,Ans],
    algebraic:true,
    a:A,
    eq:[],
    linsolvewarn:false,
    if A=0 then (
        Ans:0,
        algebraic:false,
        return(Ans)
    ),
    Dd:GCD(D,diff(D,x),x,0,0),
    if Dd=1 then (
        Ans:[0,A/D],
        algebraic:false,
        return(Ans)
    ),
    dDd:diff(Dd,x),
    Df:Group(D/Dd,x),
    n:hipow(Dd,x),
    m:hipow(Df,x),
    d:m+n-1,
    B:sum(b[i]*x^(i-1),i,1,n),
    C:sum(c[i]*x^(i-1),i,1,m),
    dB:expand(diff(B,x)),
    H:Group(A-dB*Df+B*Df*dDd/Dd-C*Dd,x),
    for k:0 thru d do eq:endcons(coeff(H,x,k)=0,eq),
    listb:makelist(b[i],i,1,n),
    listc:makelist(c[i],i,1,m),
    listvar:append(listb,listc),
    sol:solve(eq,listvar)[1],
    Rac:fullratsimp(sum(rhs(sol[i])*x^(i-1),i,1,n))/Dd,
    Log:fullratsimp(sum(rhs(sol[i])*x^(i-1-n),i,n+1,n+m))/Df,
    Ans:[Rac,Log],
    algebraic:false,
    linsolvewarn:true,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Bernoulli. Esta versÃ£o Ã© aplicada a funÃ§Ãµes com denominadores livres de quadrados. AlÃ©m disso, Ã© independente: diferente das demais funÃ§Ãµes desta seÃ§Ã£o, fornece diretamente a parte logarÃ­tmica e as funÃ§Ãµes arco tangente, efetivamente terminando a integraÃ§Ã£o. Este cÃ³digo tambÃ©m prevÃª representaÃ§Ãµes inertes das extensÃµes, as quais sÃ£o dadas sempre em termos das raÃ­zes do denominador, isto Ã©, utilizando-se a fÃ³rmula dos resÃ­duos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Bern(A,D,x,mode,solvemethod):=
block([fac,sols,a,dD,gamma,Log,ILog,Atan, pol,rea,ima,Num,expl,S,T,P,Q,Ans],
    algebraic:true,
    Log:0,
    ILog:0,
    Atan:0,
    dD:diff(D,x),
    if mode=real then (
        [P,Q]:Parts(A,x),
        [S,T]:Parts(dD,x),
        C1(a,b):=fullratsimp(subst(a,u,subst(b,v,(P*S+Q*T)/ (S^2+T^2)))),
        C2(a,b):=fullratsimp(subst(a,u,subst(b,v,(P*T-Q*S)/ (S^2+T^2))))
    ),
    fac:LFactor(D,x,false),
    sols:Solve(fac,x,solvemethod),
    sols:RHS(sols),
    for i:1 thru length(sols) do (
        a:sols[i],
        if hipow(a,x)=0 then (
            if mode=complex then (
                gamma:fullratsimp(subst(a,x,A/dD)),
                Log:Log+gamma*log(x-a)
            ),
            if mode=real then (
                rea:fullratsimp(realpart(a)),
                ima:fullratsimp(imagpart(a)),
                if ima=0 then (
                    gamma:fullratsimp(subst(rea,x,A/dD)),
                    Log:Log+gamma*log(x-rea)
                ),
                if ima>0 then (
                    pol:Group(x^2-fullratsimp(2*rea)*x +fullratsimp(rea^2+ima^2),x),
                    Log:Log+C1(rea,ima)*log(pol),
                    Atan:Atan+2*C2(rea,ima)*atan( fullratsimp((x-rea)/ima)),
                    Atan:fullratsimp(Atan)
                )
            )
        ) else (
            expl:PDiv(D,a,x)[1],
            Num:last(PFrac(A,[expl,a],x)),
            ILog:ILog+'lsum(subst(%alpha,x,fullratsimp(Num) /diff(a,x))*log(x-%alpha),%alpha,RootsOf(a))
        )
    ),
    Ans:[Log,Atan,ILog],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rothstein-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o IntRationalLogPart(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· nÃ£o nulo, livre de quadrados e coprimo com ğ´, retorna âˆ« ğ´/ğ·. 3: ğ‘§ â† uma nova indeterminada sobre K
4: ğ‘… â† resğ‘¥(ğ·,ğ´ âˆ’ ğ‘§ğ·â€² )
5: ğ‘¢ğ‘…ğ‘’1 1 Â· Â· Â· ğ‘… ğ‘’ğ‘š ğ‘š â† factoraÃ§Ã£o(ğ‘…) â— fatoraÃ§Ã£o em fatores irredutÃ­veis
6: para ğ‘– â† 1 atÃ© ğ‘š faÃ§a
7: ğ‘ â† ğ‘ | ğ‘…ğ‘–(ğ‘) = 0
8: ğºğ‘– â† mdc(ğ·,ğ´ âˆ’ ğ‘ğ·â€² ) â— computaÃ§Ã£o algÃ©brica de mdc
9: fim para
10: devolve âˆ‘ï¸ğ‘š ğ‘–=1 âˆ‘ï¸ ğ‘|ğ‘…ğ‘–(ğ‘)=0 ğ‘ log(ğºğ‘–)
11: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RothTra(A,D,x):=
block([k,expr,%Z,R,dD,Q,S,Ans],
    algebraic:true,
    Q:[],
    S:[],
    if hipow(D,x)=1 then (
        Ans:[[%Z-A/LC(D,x)],[Mon(D,x)]],
        algebraic:false,
        return(Ans)
    ),
    dD:expandwrt(diff(D,x),x),
    expr:Group(A-%Z*dD,x),
    R:content(SubRes(D,A-%Z*dD,x)[1])[2],
    Q:LFactor(R,%Z,false),
    Q:rest(Q),
    for i:1 thru length(Q) do (
        Q[i]:Q[i]^2,
        Q[i]:Group(first(Q[i]),%Z),
        S:endcons(GCD(D,expr,x,Q[i],%Z),S),
        S[i]:Normalize(S[i],x,Q[i],%Z)
    ),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Lazard-Rioboo-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o IntRationalLogPart(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· nÃ£o nulo, livre de quadrados e coprimo com ğ´, retorna âˆ« ğ´/ğ·. 3: ğ‘§ â† uma nova indeterminada sobre K
4: (ğ‘…,(ğ‘…0,ğ‘…1, . . . ,ğ‘…ğ‘˜,0)) â† SubResultantğ‘¥(ğ·,ğ´ âˆ’ ğ‘§ğ·â€² )
5: (ğ‘„1, . . . ,ğ‘„ğ‘›) â† SquareFree(ğ‘…)
6: para ğ‘– â† 1 atÃ© ğ‘› tal que grauğ‘§ (ğ‘„ğ‘–) > 0 faÃ§a
7: se ğ‘– = grau(ğ·) entÃ£o
8: ğ‘†ğ‘– â† ğ·
9: senÃ£o
10: ğ‘†ğ‘– â† ğ‘…ğ‘š onde grauğ‘¥ (ğ‘…ğ‘š) = ğ‘–, 1 â‰¤ ğ‘š â‰¤ ğ‘˜
11: (ğ´1, . . . ,ğ´ğ‘) â† SquareFree(lcğ‘¥(ğ‘†ğ‘–))
12: para ğ‘— â† 1 atÃ© ğ‘ faÃ§a
13: ğ‘†ğ‘– â† ğ‘†ğ‘–/ mdc(ğ´ğ‘— ,ğ‘„ğ‘–) ğ‘— â— divisÃ£o exata
14: fim para
15: fim se
16: fim para
17: devolve âˆ‘ï¸ğ‘› ğ‘–=1 âˆ‘ï¸ ğ‘|ğ‘„ğ‘–(ğ‘)=0 ğ‘ log(ğ‘†ğ‘–(ğ‘,ğ‘¥))
18: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LaRiTra(A,D,x):=
block([%Z,Q,R,seqR,S,degSi,lcSi,dD, k,n,q,lcSi,i,j,j1,listA,Ans],
    algebraic:true,
    dD:expand(diff(D,x)),
    R:SubRes(D,Group((A-%Z*dD),x),x),
    R[1]:Group(R[1],%Z),
    seqR:R[2],
    k:length(seqR),
    Q:SQFR(content(R[1],%Z)[2],%Z),
    n:length(Q),
    S:makelist(1,n),
    for i:1 thru n do (
        if hipow(Q[i],%Z)>0 then (
            if i=hipow(D,x) then (
                S[i]:D
            ) else (
                for j:1 thru k do (
                    if hipow(seqR[j],x)=i then (
                        S[i]:seqR[j]
                    )
                ),
                degSi:hipow(S[i],x),
                lcSi:coeff(S[i],x,degSi),
                listA:SQFR(lcSi,%Z),
                q:length(listA),
                for j1:1 thru q do (
                    S[i]:fullratsimp(S[i]/GCD(listA[j1], Q[i],t,0,0)^j1,%Z)
                )
            )
        ),
        S[i]:Group(S[i],x)
    ),
    for i:1 thru length(Q) do (
        if hipow(Q[i],%Z)=0 then (
            Q[i]:1 
        ) else (
            S[i]:Group(PDiv(S[i],Q[i],%Z)[2],x),
            S[i]:Normalize(S[i],x,Q[i],%Z)
        )
    ),
    Q:delete(1,Q),
    S:delete(1,S),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
O algoritmo de Czichowski, o qual calcula a parte logaÃ­tmica da integral de uma funÃ§Ã£o racional, da mesma forma que os algoritmos de Rothstein-Trager e Lazard-Rioboo-Trager.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o IntRationalLogPart(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· nÃ£o nulo, livre de quadrados e coprimo com ğ´, retorna âˆ« ğ´/ğ·. 3: â— CÃ¡lculo da base GrÃ¶bner reduzida
4: (ğ‘ƒ1, . . . ,ğ‘ƒğ‘š) â† ReducedGrÃ¶bner(ğ·,ğ´ âˆ’ ğ‘§ğ·â€² , olp, ğ‘¥ > ğ‘§)
5: â— (ğ‘ƒ1, . . . ,ğ‘ƒğ‘š) deve ter ordem crescente nos maiores termos
6: para ğ‘– â† 1 atÃ© ğ‘š âˆ’ 1 faÃ§a
7: ğ‘„ğ‘– â† contğ‘¥(ğ‘ƒğ‘–)/ contğ‘¥(ğ‘ƒğ‘–+1) â— divisÃ£o exata
8: ğ‘†ğ‘– â† ppğ‘¥ (ğ‘ƒğ‘–)
9: fim para
10: devolve ğ‘šâˆ‘ï¸âˆ’1 ğ‘–=1 âˆ‘ï¸ ğ‘|ğ‘„ğ‘–(ğ‘)=0 ğ‘ log(ğ‘†ğ‘–(ğ‘,ğ‘¥))
11: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
load(grobner)$
Czi(A,D,x):=
block([P,dD,m,i,Q,S,Ans],
    algebraic:true,
    P:[],
    Q:[],
    S:[],
    dD:expand(diff(D,x)),
    P:poly_reduced_grobner([D,expandwrt(A-%Z*dD,x)],[x,%Z]),
    P:sort(P),
    m:length(P),
    for i:1 thru m-1 do (
        Q:endcons(expandwrt(fullratsimp(content(P[i],x)[1] /content(P[i+1],x)[1]),%Z),Q),
        S:endcons(content(P[i+1],x)[2],S)
    ),
    Ans:[Q,S],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de clÃ¡ssico para obtenÃ§Ã£o de arcos tangentes.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Classic(A,B,x):=
block([Ans],
    algebraic:true,
    Ans:2*atan(fullratsimp(A/B)),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rioboo â€” caso complexo.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o LogToAtan(ğ´,ğµ)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 tal que ğ¼ /âˆˆ K, e ğ´,ğµ âˆˆ K[ğ‘¥] com ğµ Ì¸= 0, retorna uma soma ğ‘“ de funÃ§Ãµes arco tangente de polinÃ´mios em K[ğ‘¥] tais que ğ‘‘ğ‘“ ğ‘‘ğ‘¥ = ğ‘‘ ğ‘‘ğ‘¥ğ¼ log (ï¸‚ğ´ + ğ¼ğµ ğ´ âˆ’ ğ¼ğµ )ï¸‚ .
3: se ğµ | ğ´ entÃ£o
4: devolve 2 arctg(ğ´/ğµ)
5: fim se
6: se grau(ğ´) < grau(ğµ) entÃ£o
7: devolve LogToAtan(âˆ’ğµ,ğ´)
8: fim se
9: (ğ·,ğ¶,ğº) â† ExtendedEuclidean(ğµ, âˆ’ ğ´) â— ğµğ· âˆ’ ğ´ğ¶ = ğº
10: devolve 2 arctg((ğ´ğ· + ğµğ¶)/ğº) + LogToAtan(ğ·,ğ¶)
11: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Rioboo(A,B,x):=
block([a,b,D,C,G,Ans],
    algebraic:true,
    a:Group(A,x),
    b:Group(B,x),
    if PDiv(a,b,x)[2]=0 then (
        algebraic:false,
        return(2*atan(Group(a/b,x)))
    ),
    if hipow(a,x)<hipow(b,x) then (
        algebraic:false,
        return(Rioboo(-b,a,x))
    ),
    [D,C,G]:HFExGCD(b,-a,x),
    Ans:2*atan(Group((a*D+b*C)/G,x))+Rioboo(D,C,x),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Rioboo â€” caso geral.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Rioboo2(A,B,alpha,x,N):=
block([a,b,D,C,G,n,pol,Ans],
    algebraic:true,
    if N=0 then (
        Ans:alpha*log(A+alpha*B)-alpha*log(A-alpha*B),
        algebraic:false,
        return(Ans)
    ),
    a:Group(A,x),
    b:Group(B,x),
    if PDiv(a,b,x)[2]=0 then (
        pol:PDiv(Group(a/(alpha*b),x),alpha,x)[1],
        Ans:ratsimp(2*alpha*atanh(alpha*pol)),
        algebraic:false,
        return(Ans)
    ),
    if hipow(a,x)<hipow(b,x) then (
        Ans:Rioboo2(alpha^2*b,a,alpha,x,N),
        algebraic:false,
        return(Ans)
    ),
    [D,C,G]:HFExGCD(b,-a,x),
    n:N-1,
    pol:ratsimp(PDiv(Group((a*D-alpha^2*b*C)/(alpha*G),x), alpha,x)[1]),
    Ans:2*alpha*atanh(alpha*pol)+Rioboo2(D,C,alpha,x,n),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente inerte. Dado um polinÃ´mio irredutÃ­vel ğ‘ƒ, retorna a lista [0 = ğ‘ƒ].
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
NoSolve(P,x):=
block([Ans],
    algebraic:true,
    Ans:[0=P],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente de domÃ­nio. Dado um polinÃ´mio irredutÃ­vel ğ‘ƒ, resolve-o se ele puder se escrito na forma ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥ + ğ‘, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DomSolve(P,x):=
block([sols,Ans],
    algebraic:true,
    sols:NoSolve(P,x),
    if hipow(P,x)=1 then (
        Ans:solve(P,x),
        algebraic:false,
        return(Ans)
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente linear. Dado um polinÃ´mio irredutÃ­vel ğ‘ƒ, resolve-o se ele puder se escrito na forma ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥ğ‘› + ğ‘, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
LinSolve(P,x):=
block([sols,aux,Ans],
    algebraic:true,
    sols:DomSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if hipow(aux,x)=lopow(aux,x) then (
            Ans:solve(P,x),
            algebraic:false,
            return(Ans)
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente quadrÃ¡tico. Dado um polinÃ´mio irredutÃ­vel ğ‘ƒ, resolve-o se ele puder se escrito na forma ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥2ğ‘› + ğ‘ğ‘¥ğ‘› + ğ‘, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
QuadSolve(P,x):=
block([degP,sols,aux,Ans],
    algebraic:true,
    sols:LinSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if length(aux)=2 then (
            degP:hipow(P,x),
            if mod(degP,2)=0 then (
                if (coeff(P,x,degP/2))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente cÃºbico. Dado um polinÃ´mio irredutÃ­vel ğ‘ƒ, resolve-o se ele puder se escrito na forma ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥3ğ‘› + ğ‘ğ‘¥ğ‘› + ğ‘, ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥3ğ‘› + ğ‘ğ‘¥2ğ‘› + ğ‘, ou ğ‘ƒ(ğ‘¥) = ğ‘ğ‘¥3ğ‘› + ğ‘ğ‘¥2ğ‘› + ğ‘ğ‘¥ğ‘› + ğ‘‘, onde os coeficientes podem ser nulos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
CubeSolve(P,x):=
block([degP,sols,aux,Ans],
    algebraic:true,
    sols:QuadSolve(P,x),
    if lhs(last(sols))=0 then (
        aux:P,
        aux:fullratsimp(aux-coeff(aux,x,0)),
        if length(aux)=2 then (
            degP:hipow(P,x),
            if mod(degP,3)=0 then (
                if (coeff(P,x,degP/3))#0 or (coeff(P,x,2*degP/3))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        ),
        if length(aux)=3 then (
            degP:hipow(P,x),
            if mod(degP,3)=0 then (
                if (coeff(P,x,degP/3))#0 and (coeff(P,x,2*degP/3))#0 then (
                    Ans:solve(P,x),
                    algebraic:false,
                    return(Ans)
                )
            )
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Solvente geral. ğ‘“ ğ‘ğ‘ Ã© uma lista de fatores de ğ‘ƒ na variÃ¡vel ğ‘¥ obtida utilizando-se a funÃ§Ã£o ListFactor. A funÃ§Ã£o encontra cada uma das raÃ­zes de ğ‘ƒ utilizando o mÃ©todo ğ‘šğ‘’ğ‘¡â„ğ‘œğ‘‘ em cada um de seus fatores irredutÃ­veis. ğ‘šğ‘’ğ‘¡â„ğ‘œğ‘‘ pode ser: NoSolve, DomSolve, LinSolve, QuadSolve, CubeSolve ou solve, esta Ãºltima sendo o solvente nativo do MÃ¡xima.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Solve(fac,x,method):=
block([P,l,i,solsfac,sols,unsolved,Ans],
    algebraic:true,
    l:length(fac),
    sols:[],
    unsolved:1,
    if l=1 then (
        algebraic:false,
        error("polynomial is constant or 0.")
    ),
    for i:2 thru l do (
        P:fac[i]^2,
        P:first(P),
        P:Group(P,x),
        solsfac:method(P,x),
        if lhs(last(solsfac))=0 then unsolved:unsolved*rhs(last(solsfac)) else sols:append(sols,solsfac)
    ),
    if unsolved=1 then (
        Ans:sols,
        algebraic:false,
        return(Ans)
    ) else (
        Ans:append(sols,[0=unsolved]),
        algebraic:false,
        return(Ans)
    )
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Converte uma lista cujos elementos sÃ£o da forma ğ‘™â„ğ‘  = ğ‘Ÿâ„ğ‘  em uma lista cujos elementos sÃ£o da forma ğ‘Ÿâ„ğ‘ . Essa funÃ§Ã£o se aplica a listas de soluÃ§Ãµes de um polinÃ´mio.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RHS(sols):=
block([consts,i,Ans],
    algebraic:true,
    consts:[],
    for i:1 thru length(sols) do consts:endcons(rhs(sols[i]),consts),
    Ans:consts,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Dada uma lista de nÃºmeros complexos, retorna uma lista cujos elementos sÃ£o da forma [ğ‘,ğ‘], com ğ‘,ğ‘ âˆˆ R, ğ‘ > 0 e tais que ğ‘+ğ¼ğ‘ pertence Ã  lista original. Aplica-se ao sistema nÃ£o linear que surge na discussÃ£o do algoritmo de Rioboo.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
SolveSys(compl):=
block([a,b,j,sols,Ans],
    algebraic:true,
    sols:[],
    for j:1 thru length(compl) do (
        a:fullratsimp(realpart(compl[j])),
        b:fullratsimp(imagpart(compl[j])),
        if b>0 then (
            sols:endcons([a,b],sols)
        )
    ),
    Ans:sols,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Dada uma lista de fatores ğ‘… na variÃ¡vel ğ‘§ resolve cada um dos fatores utilizando o mÃ©todo ğ‘ ğ‘œğ‘™ğ‘£ğ‘’ğ‘šğ‘’ğ‘¡â„ğ‘œğ‘‘ e armazena, respectivamente, nas listas ğ‘Ÿğ‘’ğ‘– , ğ‘ğ‘œğ‘šğ‘ğ‘™ğ‘– e ğ‘–ğ‘›ğ‘’ğ‘Ÿğ‘¡ğ‘– as soluÃ§Ãµes reais, contendo unidade imaginÃ¡ria e o que nÃ£o pÃ´de ser resolvido do fator ğ‘…ğ‘– . Utilizada para encontrar as extensÃµes que devem aparecer na expressÃ£o final da integral de uma funÃ§Ã£o racional.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
Extensions(R,z,solvemethod):=
block([l,i,j,exts,re,compl,inert,fac,Ans],
    algebraic:true,
    l:length(R),
    re:[],
    compl:[],
    inert:[],
    for i:1 thru l do (
        fac:LFactor(R[i],z,false),
        exts:RHS(Solve(fac,z,solvemethod)),
        re:endcons([],re),
        compl:endcons([],compl),
        inert:endcons([],inert),
        for j:1 thru length(exts) do (
            if hipow(exts[j],z)#0 then inert[i]:endcons(exts[j],inert[i]) else if imagpart(exts[j])#0 then compl[i]:endcons(exts[j],compl[i]) else re[i]:endcons(exts[j],re[i])
        )
    ),
    Ans:[re,compl,inert],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Verifica se todos os elementos da lista ğ‘ ğ‘œğ‘™ğ‘  possuem apenas elementos racionais em alguma das duas coordenadas. A resposta Ã© um vetor booleano de dois elementos. O valor ğ‘¡ğ‘Ÿğ‘¢ğ‘’ indica que todas os elementos das coordenadas correspondentes sÃ£o racionais.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
VerifyRatSols(sols):=
block([i,signal1,signal2,a,b,Ans],
    algebraic:true,
    signal1:true,
    signal2:true,
    for i:1 thru length(sols) do (
        a:sols[i][1],
        b:sols[i][2],
        if (integerp(num(a)) and integerp(denom(a)))=false then signa1:false,
        if (integerp(num(b)) and integerp(denom(b)))=false then signa2:false
    ),
    Ans:[signal1,signal2],
    algebraic:true,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Monta os logaritmos reais que aparecem na expressÃ£o final da integral, mas que nÃ£o sÃ£o obtidos a partir de extensÃµes contendo unidade imaginÃ¡ria. Algumas conversÃµes simples para funÃ§Ãµes arco tangente hiperbÃ³lico sÃ£o realizadas quando temos a condiÃ§Ã£o ğµ(ğ‘,ğ‘,ğ‘¥) | ğ´(ğ‘,ğ‘,ğ‘¥).
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
RealLog(S,z,x,re,modei,atanhconv):=
block([i,j,RLog,Atanh,expl,SubS,Swap,a,b,M,m,A,B,q],
    algebraic:true,
    RLog:0,
    expl:1,
    Atanh:0,
    for i:1 thru length(S) do (
        if length(re[i])=2 and atanhconv=true and (re[i][1]=-re[i][2] or rationalp(re[i][1])=false) then (
            a:(re[i][1]+re[i][2])/2,
            b:abs(re[i][1]-re[i][2])/2,
            M:max(re[i][1],re[i][2]),
            m:min(re[i][1],re[i][2]),
            A:Group((subst(M,z,S[i])+subst(m,z,S[i]))/2,x),
            B:Group((subst(M,z,S[i])-subst(m,z,S[i]))/2,x),
            if hipow(A,x)<hipow(B,x) then (
                Swap:A,
                A:b^2*B,
                B:b*Swap
            ),
            [q,r]:PDiv(A,B,x),
            if r=0 then (
                SubS:fullratsimp(A^2-B^2),
                RLog:RLog+a*log(SubS),
                if modei=den then expl:expl*SubS,
                Atanh:Atanh+2*b*atanh(q)
            ) else (
                for j:1 thru 2 do (
                    a:fullratsimp(re[i][j]),
                    SubS:content(subst(a,z,S[i]),x)[2],
                    if modei=den then expl:expl*SubS,
                    SubS:Mon(SubS,x),
                    RLog:RLog+a*log(SubS)
                )
            )
        ) else (
            for j:1 thru length(re[i]) do (
                a:fullratsimp(re[i][j]),
                SubS:content(subst(a,z,S[i]),x)[2],
                if modei=den then expl:expl*SubS,
                SubS:Mon(SubS,x),
                RLog:RLog+a*log(SubS)
            )
        )
    ),
    RLog:ratsimp(RLog),
    Atanh:ratsimp(Atanh),
    Ans:[expl,RLog,Atanh],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Se nÃ£o estivermos interessados em realizar conversÃµes para arcos tangentes, esta funÃ§Ã£o monta os logaritmos complexos que aparecem na expressÃ£o final da integral. Caso contrÃ¡rio, monta os logaritmos e funÃ§Ãµes arco tangente que surgem de extensÃµes contendo unidades imaginÃ¡rias. No caso real, resolve o sistema ğ‘ƒ(ğ‘¢,ğ‘£) = ğ‘„(ğ‘¢,ğ‘£) encontrando diretamente as raÃ­zes complexas com parte imaginÃ¡ria positiva de ğ‘…(ğ‘§).
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o LogToReal(ğ‘…,ğ‘†)
2: descriÃ§Ã£o: Dado um corpo K âŠ† R, ğ‘… âˆˆ K[ğ‘§] e ğ‘† âˆˆ K[ğ‘§,ğ‘¥], retorna uma funÃ§Ã£o real ğ‘“ tal que ğ‘‘ğ‘“ ğ‘‘ğ‘¥ = ğ‘‘ ğ‘‘ğ‘¥ âˆ‘ï¸ ğ›¼|ğ‘…(ğ›¼)=0 ğ›¼ log(ğ‘†(ğ›¼,ğ‘¥)).
3: Escreva ğ‘…(ğ‘¢ + ğ¼ğ‘£) = ğ‘ƒ(ğ‘¢,ğ‘£) + ğ¼ğ‘„(ğ‘¢,ğ‘£)
4: Escreva ğ‘†(ğ‘¢ + ğ¼ğ‘£,ğ‘¥) = ğ´(ğ‘¢,ğ‘£,ğ‘¥) + ğ¼ğµ(ğ‘¢,ğ‘£,ğ‘¥)
5: devolve âˆ‘ï¸ ğ‘,ğ‘âˆˆR,ğ‘>0 ğ‘ƒ (ğ‘,ğ‘)=ğ‘„(ğ‘,ğ‘)=0 ğ‘ log(ğ´(ğ‘,ğ‘,ğ‘¥) 2 + ğµ(ğ‘,ğ‘,ğ‘¥) 2 )+ ğ‘ LogToAtan(ğ´,ğµ)(ğ‘,ğ‘,ğ‘¥) + âˆ‘ï¸ ğ‘âˆˆR,ğ‘…(ğ‘)=0 ğ‘ log(ğ‘†(ğ‘,ğ‘¥))
6: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
ComplLog(S,R,z,x,expl,compl,mode,modei,atanmethod):=
block([i,j,k,a,b,x,u,v,CLog,Atan,Expl, SubS,SubA,SubB,A,B,sols,signal1,signal2,auxatan,Ans],
    algebraic:true,
    CLog:0,
    Atan:0,
    Expl:expl,
    if mode=complex then (
        for i:1 thru length(S) do (
            for j:1 thru length(compl[i]) do (
                a:fullratsimp(compl[i][j]),
                SubS:content(subst(a,z,S[i]),x)[2],
                if modei=den then Expl:Expl*SubS,
                SubS:Mon(SubS,x),
                CLog:CLog+a*log(SubS)
            )
        )
    ),
    if mode=real then (
        for i:1 thru length(S) do (
            if length(compl[i])>0 then (
                [SubA,SubB]:Parts(S[i],z),
                A(a,b,x):=subst(a,u,subst(b,v,SubA)),
                B(a,b,x):=subst(a,u,subst(b,v,SubB)),
                sols:SolveSys(compl[i]),
                [signal1,signal2]:VerifyRatSols(sols),
                if (signal1 or signal2)=false then (
                    auxatan:atanmethod(A(u,v,x),B(u,v,x),x)
                ),
                for j:1 thru length(sols) do (
                    a:sols[j][1],
                    b:sols[j][2],
                    SubS:content(A(a,b,x)^2+B(a,b,x)^2,x)[2],
                    SubS:Mon(SubS,x),
                    if modei=den then Expl:Expl*SubS,
                    CLog:CLog+a*log(SubS),
                    if signal1=false and signal2=true then (
                        auxatan:atanmethod(A(u,b,x), B(u,b,x),x)
                    ),
                    if signal1=true and signal2=false then (
                        auxatan:atanmethod(A(a,v,x), B(a,v,x),x)
                    ),
                    if signal1=true and signal2=true then (
                        auxatan:atanmethod(A(a,b,x), B(a,b,x),x)
                    ),
                    auxatan:subst(a,u,subst(b,v,auxatan)),
                    Atan:Atan+b*auxatan,
                    Atan:fullratsimp(Atan)
                )
            )
        )
    ),
    Ans:[Expl,CLog,Atan],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Monta as expressÃµes inertes da integral. Se certos resÃ­duos nÃ£o puderam ser encontrados durante o processo de integraÃ§Ã£o, entÃ£o a porÃ§Ã£o da integral que depende deles Ã© deixada na forma inerte, isto Ã©, como uma soma de logaritmos sobre as raÃ­zes de um determinado polinÃ´mio.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
InertLog(S,z,x,h,inert,expl,modei):=
block([i,j,ILog,SubS,impl,Num,Ans],
    algebraic:true,
    ILog:0,
    if modei=den then (
        impl:Group(denom(h)/expl,x),
        if hipow(impl,x)=0 then (
            Ans:ILog,
            algebraic:false,
            return(Ans)
        ),
        Num:last(PFrac(num(h),[expl,impl],x)),
        ILog:'lsum(subst(%alpha,x,fullratsimp(Num)/ fullratsimp(diff(impl,x)))*log(x-%alpha), %alpha,RootsOf(content(impl,x)[2]))
    ),
    if modei=res then (
        for i:1 thru length(S) do (
            for j:1 thru length(inert[i]) do (
                SubS:PPsDiv(S[i],inert[i][j],z)[2],
                SubS:content(Group(subst(%gamma,z,SubS), x),x)[2],
                if integerp(LC(SubS,x)) then SubS:Mon(SubS,x),
                ILog:ILog+'lsum(%gamma*log(SubS),%gamma, RootsOf(inert[i][j]))
            )
        )
    ),
    Ans:ILog,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Converte um vetor de caracteres em uma lista que contÃ©m as opÃ§Ãµes para o funcionamento do algoritmo de integraÃ§Ã£o. Serve para facilitar a mudanÃ§a de opÃ§Ãµes, dispensando a necessidade de digitÃ¡-las por extenso, o que torna o processo de testes dos cÃ³digos mais rÃ¡pidos.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
GenList(opt):=
block([solvemethod,mode,modei,ratmethod,logmethod, atanmethod,Ans],
    algebraic:true,
    if opt[1]=N then solvemethod:NoSolve,
    if opt[1]=D then solvemethod:DomSolve,
    if opt[1]=L then solvemethod:LinSolve,
    if opt[1]=Q then solvemethod:QuadSolve,
    if opt[1]=C then solvemethod:CubeSolve,
    if opt[1]=A then solvemethod:solve,
    if opt[2]=C then mode:complex,
    if opt[2]=R then mode:real,
    if opt[3]=R then modei:res,
    if opt[3]=D then modei:den,
    if opt[4]=O then ratmethod:HermO,
    if opt[4]=Q then ratmethod:HermQ,
    if opt[4]=L then ratmethod:HermL,
    if opt[4]=S then ratmethod:HorOstro,
    if opt[5]=B then logmethod:Bern,
    if opt[5]=R then logmethod:RothTra,
    if opt[5]=L then logmethod:LaRiTra,
    if opt[5]=C then logmethod:Czi,
    if opt[6]=C then atanmethod:Classic,
    if opt[6]=R then atanmethod:Rioboo,
    if opt[7]=T then atanhconv:true,
    if opt[7]=F then atanhconv:false,
    Ans:[solvemethod,mode,modei,ratmethod,logmethod, atanmethod,atanhconv],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Integrador de funÃ§Ãµes racionais. A saÃ­da Ã© uma lista em que a primeira entrada contÃ©m dados separados de cada etapa do processo de integraÃ§Ã£o e a segunda contÃ©m a fÃ³rmula da integral.
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
IRF(F,x,solvemethod,mode,modei,ratmethod,logmethod, atanmethod,atanhconv):=
block([f,q,r,h,t,Poly,Rat,Log,ILog, compl,inert,R,S,Atan,Atanh,re, expl,impl,RLog,CLog,Int,Ans],
    algebraic:true,
    q:0,
    r:0,
    h:0,
    Poly:0,
    Rat:0,
    Log:0,
    ILog:0,
    re:[],
    compl:[],
    inert:[],
    R:[],
    S:[],
    Atan:0,
    Atanh:0,
    expl:1,
    impl:1,
    RLog:0,
    CLog:0,
    Int:0,
    f:Group(num(F),x)/Group(denom(F),x),
    [q,r]:PDiv(num(f),denom(f),x),
    Poly:integrate(q,x),
    Int:Int+Poly,
    if r=0 then (
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    [Rat,h]:ratmethod(num(r),denom(f),x),
    h:rat(h,x),
    Int:Int+Rat,
    if h=0 then (
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    if logmethod=Bern then (
        [Log,Atan,ILog]:logmethod(num(h),denom(h),x,mode, solvemethod),
        Int:Int+(Log+Atan)+ILog,
        Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
        algebraic:false,
        return(Ans)
    ),
    [R,S]:logmethod(num(h),denom(h),x),
    [re,compl,inert]:Extensions(R,%Z,solvemethod),
    [expl,RLog,Atanh]:RealLog(S,%Z,x,re,modei,atanhconv),
    [expl,CLog,Atan]:ComplLog(S,R,%Z,x,expl,compl,mode,modei ,atanmethod),
    ILog:InertLog(S,%Z,x,h,inert,expl,modei),
    Int:Int+(RLog+CLog+Atan+Atanh)+ILog,
    Ans:[[[Poly,Rat,h],[R,S],[re,compl,inert]],Int],
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Calcula um polinÃ´mio ğ‘‰ tal que, caso a equaÃ§Ã£o ğ‘” = (ğ‘¢/ğ‘£)ğ‘“, com ğ‘” â€² = ğ‘“ possua soluÃ§Ã£o no par ğ‘¢,ğ‘£, entÃ£o ğ‘‰ Ã© um mÃºltiplo de ğ‘£.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o DenMult(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· mÃ´nico e coprimo com ğ´, retorna ğ‘‰ âˆˆ K[ğ‘¥], tal que, para quaisquer coprimos ğ‘¢,ğ‘£ âˆˆ K[ğ‘¥], a equaÃ§Ã£o (A.2) implica que ğ‘£ divide ğ‘‰ .
3:
4: ğ‘… â† resğ‘¥(ğ·,ğ´ âˆ’ ğ‘§ğ·â€² )
5: ğ‘‘ â† max{ğ‘– âˆˆ N | ğ‘– = 0 ou ğ‘…(ğ‘–) = 0}
6: se ğ‘‘ = 0 entÃ£o
7: devolve 1
8: fim se
9: ğ‘0 â† ğ´, ğ‘0 â† ğ·
10: para ğ‘– â† 1 atÃ© ğ‘‘ faÃ§a
11: ğ»ğ‘– â† mdc(ğ‘ğ‘–âˆ’1,ğ‘ğ‘–âˆ’1 âˆ’ ğ‘ â€² ğ‘–âˆ’1 ), ğ‘ğ‘– â† ğ‘ğ‘–âˆ’1 âˆ’ ğ‘ â€² ğ‘–âˆ’1 ğ»ğ‘– , ğ‘ğ‘– â† ğ‘ğ‘–âˆ’1 ğ»ğ‘–
12: fim para
13: devolve ğ»1ğ» 2 2 Â· Â· Â· ğ» ğ‘‘ ğ‘‘
14: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
DenMult(A,D,x):=
block([expr,expr2,R,i,%Z,d,k,V,Hi,a,b,Ans],
    algebraic:true,
    expr:A-%Z*diff(D,x),
    d:0,
    k:1,
    V:1,
    R:SubRes(D,expr,x)[1],
    R:LFactor(R,%Z,false),
    if length(R)=1 then (
        Ans:1,
        algebraic:false,
        return(Ans)
    ),
    R:Solve(R,%Z,DomSolve),
    while (k<=length(R) and lhs(R[k])#0) do (
        i:rhs(R[k]),
        if integerp(i) and d<i then d:i,
        k:k+1
    ),
    if d=0 then (
        Ans:V,
        algebraic:false,
        return(Ans)
    ),
    a:A,
    b:D,
    for i:1 thru d do (
        expr2:a-diff(b,x),
        Hi:GCD(b,a-diff(b,x),x,0,0),
        a:expr2/Hi,
        b:b/Hi,
        V:V*Hi^i 
    ),
    Ans:V,
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */


/* [wxMaxima: comment start ]
Algoritmo de Almkvist-Zeilberger. Encontra a integral de uma funÃ§Ã£o hiperexponencial, desde que esta integral seja tambÃ©m uma funÃ§Ã£o hiperexponencial.
   [wxMaxima: comment end   ] */


/* [wxMaxima: comment start ]
1: funÃ§Ã£o HyperIntegration(ğ´,ğ·)
2: descriÃ§Ã£o: Dado um corpo K de caracterÃ­stica 0 e ğ´,ğ· âˆˆ K[ğ‘¥] com grau(ğ´) < grau(ğ·), ğ· mÃ´nico e coprimo com ğ´, retorna ğ‘¢,ğ‘£ âˆˆ K[ğ‘¥], com ğ‘£ mÃ´nico, satisfazendo (A.2)
3:
4: ğ‘‰ â†DenMult(ğ´,ğ·)
5: â„ â† mdc(ğ·ğ‘‰,ğµğ‘‰ â€² âˆ’ ğ´ğ‘‰ ), ğ‘Ÿ â† ğ·ğ‘‰ â„ , ğ‘  â† ğ·ğ‘‰ â€² âˆ’ ğ´ğ‘‰ â„ , ğ‘¡ â† ğ‘Ÿğ‘‰
6: ğ‘š â† max{grau(ğ‘Ÿ) âˆ’ 1, grau(ğ‘ )}
7: ğ›¿ â† coeficiente(ğ‘ ,ğ‘¥ğ‘š)
8: se grau(ğ‘Ÿ) âˆ’ 1 < grau(ğ‘ ) ou ğ›¿ /âˆˆ N entÃ£o
9: ğ‘’ â† grau(ğ‘¡) âˆ’ ğ‘š
10: senÃ£o
11: se grau(ğ‘¡) âˆ’ ğ‘š = ğ›¿ entÃ£o
12: devolve â€œinsolÃºvelâ€
13: senÃ£o
14: ğ‘’ â† max{grau(ğ‘¡) âˆ’ ğ‘š,ğ›¿}
15: fim se
16: fim se
17: se ğ‘’ < 0 entÃ£o
18: devolve â€œinsolÃºvelâ€
19: fim se
20: ğ‘ˆ â† ğ‘’âˆ’grau( âˆ‘ï¸ ğ‘Ÿ) ğ‘–=0 ğ‘¢ğ‘–ğ‘¥ ğ‘–
21: ğ» â† ğ‘‰ âˆ’ ğ‘Ÿğ‘ˆâ€² + (ğ‘  âˆ’ ğ‘Ÿ â€² ) 
22: (ğ‘ˆ0, . . . ,ğ‘ˆğ‘’âˆ’grau(ğ‘Ÿ)) â† solucionador(coeficiente(ğ»,ğ‘¥ğ‘˜ ) = 0,0 â‰¤ ğ‘˜ â‰¤ ğ‘’ âˆ’ grau(ğ‘Ÿ))
23: se @(ğ‘ˆ0, . . . ,ğ‘ˆğ‘’âˆ’grau(ğ‘Ÿ)) | ğ» = 0 entÃ£o
24: devolve â€œinsolÃºvelâ€
25: senÃ£o
26: devolve ğ‘Ÿğ‘ˆ mdc(ğ‘Ÿğ‘ˆ,ğ‘‰ ) , ğ‘‰ mdc(ğ‘Ÿğ‘ˆ,ğ‘‰ )
27: fim se
28: fim funÃ§Ã£o
   [wxMaxima: comment end   ] */


/* [wxMaxima: input   start ] */
IHF(f,x):=
block([A,D,h,r,s,t,m,delta,sigma, e,U,V,H,eq,listu,u,sol,G,Ans],
    algebraic:true,
    eq:[],
    sigma:ratsimp(diff(f,x)/f),
    A:num(sigma),
    D:denom(sigma),
    if (polynomialp(A,[x]) and polynomialp(D,[x]))=false then error("not a hyperexponential function."),
    V:DenMult(A,D,x),
    h:GCD(D*V,D*diff(V,x)-A*V,x,0,0),
    r:Group(D*V/h,x),
    s:Group((D*diff(V,x)-A*V)/h,x),
    t:Group(r*V,x),
    m:max(hipow(r,x)-1,hipow(s,x)),
    delta:coeff(s,x,m),
    if hipow(r,x)-1<hipow(s,x) or (integerp(delta) and delta>=0)=false then e:hipow(t,x)-m else if hipow(t,x)-m=delta then (
        Ans:"unsolvable",
        algebraic:false,
        return(Ans)
    ) else e:max(hipow(t,x)-m,delta),
    if e<0 then (
        Ans:"unsolvable",
        algebraic:false,
        return(Ans)
    ),
    U:sum(u[i]*x^(i-1),i,1,e-hipow(r,x)+1),
    H:Group(V-r*diff(U,x)+(s-diff(r,x))*U,x),
    for k:0 thru hipow(H,x) do (
        eq:endcons(coeff(H,x,k)=0,eq)
    ),
    listu:makelist(u[i],i,1,e-hipow(r,x)+1),
    sol:linsolve(eq,listu),
    U:sum(rhs(sol[i])*x^(i-1),i,1,length(sol)),
    if sol=[] then (
        Ans:"unsolvable",
        algebraic=false,
        return(Ans)
    ),
    G:ratsimp(r*U/V),
    Ans:fullratsimp(G*f),
    algebraic:false,
    return(Ans)
)$
/* [wxMaxima: input   end   ] */



/* Old versions of Maxima abort on loading files that end in a comment. */
"Created with wxMaxima 22.04.0"$
